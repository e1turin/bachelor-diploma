#import "prelude.typ": *
#import "title-page.typ": title_page

#let title = "Диплом"
#let author = "Тюрин Иван Николаевич"

#show: thesis_format.with(
  title, 
  author, 
  title_page: [
    // no pagebreak as struct alements do so
    // #title_page(
    //   author: author, 
    //   title: title
    // )
  ],
)

// #struct(outlined: false)[СОДЕРЖАНИЕ]
#outline(title: [
  #block(
    inset: (left: 50%),
    align(center)[
      // #set text(14pt)
      СОДЕРЖАНИЕ
    ]
  )
])

#struct[ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ] <ТЕРМИНЫ_И_ОПРЕДЕЛЕНИЯ>
// = ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ

/ API:
/ ABI:
/ Gradle:
/ HDL:
/ Circulator: название разрабатываемого решения.
/ Native: #lorem(10)
/ Kotlin:
/ Нативные (модели/код): модели/код реализованные на наиболее низкоуровневом языке (для JVM - bin, для wasm - wasm) (от англ. native — "родной") — это машинный код, который выполняется процессором напрямую без дополнительных слоев интерпретации или трансляции. ...
/ Мультиплатформенный: 
/ Сорсет: source set
/ JVM:
/ JDK:
/ WASM:
/ Промежуточное представление: внутреннее представление ...
/ CIRCT: 
/ Диалект:
/ CIRCT IR:
/ LLVM:
/ LLVM IR:
/ Фреймворк: 

#struct[ВВЕДЕНИЕ] <ВВЕДЕНИЕ>
// = ВВЕДЕНИЕ

При построении сложных систем, немаловажным является вопрос их тестирования, при
этом тестирование с использованием реального оборудования может быть очень
рисковано --- приборы могут быть дорогостоящими или даже уникальными, а выход из
строя хотя бы одного из них приведет к значительным временным потерям, не считая
финансовых затрат. Отсюда возникает необходимость в использовании "виртуальных
устройств", которые создают уровень абстракции между системой управления и
оборудованием, что позволяет незаметно для компонентов системы подменять
реализацию устройства. Например, виртуальное устройство будет имитировать
поведение прибора, но в нужный момент его переключат на реальный прибор.

Моделирование работы прибора может производиться различными способами, но в любом
случае эта задача требует дополнительных усилий по разработке модели и поддержания
ее актуальности. Кроме того, чем точнее модель и сложнее устройство, тем труднее
ее разработать человеческими усилиями, что серьезно затрудняет или даже делает
невозможным сквозное тестирование модели системы, Если же прибор во время
построения системы находится в разработке, то затраты на поддержание
актуальности модели так же возрастают. 

В данной научной работе исследуются пути решения и описывается разработанное
решение для задачи моделирования аппаратуры.

= Обзор предметной области

В этой главе дается описание предметной области, рассматриваются имеющиеся
решения и технологии, которые важны при проектировании своего решения.
Рассмотрения в главе требуют область применения и целевой фреймворк для
построения SCADA-систем, языки описания аппаратуры, промежуточное представление
для цифровых схем, средства моделирования приборов и способы взаимодейтсвия
программного кода на платформе JVM с внешним для нее кодом.

== Область применения

Основной целевой областью применения разрабатываемого решения является
аппаратно-программная система, обладающая следующими свойствами:
- поддерживает компонентное моделирование, 
- не требовательная к реальному времени, то есть не критичная к
  производительности моделей,
- поддерживающая разработку на высокоуровневом языке программирования Kotlin или
  другом языке JVM-платформы.

#noindent[
  В частности, такие системы разрабатываются с использованием фреймоворка "Controls.kt".
]

"Controls.kt" --- это фреймворк на языке программирования Kotlin,
разрабатываемый Центром научного программирования МФТИ /* TODO: https://sciprog.center/ */.
Фреймворк базируется на ядре фреймворка для работы с данными --- DataForge,
который разрабатывался совместно с подразделением JetBrains Research
/* TODO: (https://doi.org/10.1051/epjconf/201817705003) */. Controls.kt предназначен, как
заявляют его авторы, для создания "легковестных" SCADA-систем, а его особенность
заключается в том, что он использует асинхронный подход для коммуникации между
устрайствами, что расширяет границы применимости фреймворка. Кроме того
фреймворк дает необходимые абстракции для использования виртульных устройств.

Наиболее известным примером применения "Controls.kt" является установка,
использовавшаяся в научном эксперименте по изучению нейтрино, публично
известном, как
#quote([''Troisk nu-mass,, experiment])/*: TODO: https://www.inr.ru/~numass/,
https://doi.org/10.1088/1742-6596/1525/1/012024 */

В настоящий момент фокус фреймворка сместился в сторону моделирования систем,
примерами чего могут служить демонстрационные проекты в репозитории с исходными
кодами и сообщения автора проект в публичном чате. Перед разработчиками
фреймворка встала задача моделирования работы устройств на уровне цифровых схем,
чтобы добиться полного сквозного тестирования разрабатываемой системы еще до
момента изготовления всех используемых устройств. Такой подход позволяет
повысить качество работы разрабатываемой системы и снизить затраты за
счет раннего обнаружения проблем в дизайне аппаратных компонентов.

Использование асинхронного подхода в работе фреймворка Controls.kt накладывает
сложности на его реализацию. Фреймворк берет на себя решение проблемы
согласованости "виртуального" времени отдельных приборов, что позволяет
интегрировать в одну систему устройства разных типов, в частности, это позволяет
использовать модели цифровых схем приборов, несмотря на их низкую
производительность и отзывчивость в сравнении с реальными приборами.


== Языки описания аппаратуры
// выбор HDL

Языки описания аппаратуры --- HDL --- играют ключевую
роль в проектировании и разработке цифровых систем. Они позволяют инженерам
описывать поведение и структуру аппаратных компонентов на различных уровнях
абстракции, начиная от логических вентилей и заканчивая сложными системами на
кристалле.

Наиболее популярными языками HDL являются Verilog, SystemVerilog, VHDL, также
встречаются примеры использования SystemC и Chisel. Кроме того существует
малоизвестный язык Verik. Каждый из них имеет свои особенности и области
применения.

*Verilog и SystemVerilog* --- индустриальные стандарты, широко используемые для
проектирования и верификации цифровых систем. SystemVerilog является
расширением Verilog и предоставляет дополнительные возможности, благодаря чему
набирает большую популярность.

*VHDL* --- ещë один популярный язык описания аппаратуры и индустриальный
стандарт с большой историей, который отличается от семейства Verilog большей
вербозностью кода.

*SystemC* --- библиотека и доммено-ориентированный язык описания
систем на основе языка программирования C++. Инструмент предназначен для
моделирования аппаратных систем на уровне системного проектирования. SystemC
позволяет интегрировать моделирование аппаратуры и программного обеспечения, что
делает его особенно полезным для проектирования встраиваемых систем. Также он
является языко высокоуровневого синтеза (HLS, High-level synthesis) для некоторых
специализированных средств проектирования. /* TODO: ссылка на сайт https://systemc.org/overview/systemc/ */

*Chisel* --- плагин для компилятора и доменно-ориентированны язык описания
аппаратуры, основанный на языке программирования Scala. Chisel является новым
по сравнению с другими классическими HDL, он предоставляет высокоуровневый
функциональный подход к проектированию цифровых систем и использует промежуточное
представление для интеграции со сторонними инструментами. В ранних версиях
язык полагался на самостоятельно разработанное промежуточное представление
FIRRTL (Flexible Intermediate Representation for RTL), но в новых версиях проект,
развиваший FIRRTL, объявлен архивным и разработчики рекомендуют использовать
промежуточное представление из проекта LLVM CIRCT. Изначально инструмент был
разработан в Калифорнийском университете в Беркли, а теперь развивается
организацией Chips Alliance The Linux Foundation. /* TODO
ссылка на офф сайт */ Этот язык широко применяется для генерации аппаратных
блоков различных процессоров.

*Verik* --- новый и малоизвестный язык описания аппаратуры, основанный на Kotlin. Verik
ориентирован на упрощение проектирования цифровых систем и интеграцию с
современными инструментами разработки. Инструмент использует язык SystemVerilog
как промежуточное представление: позволяет импортировать модули на этом языке и
сам компилируется в этот язык. /* TODO ссылка на вкр */

Представленный список языков для описания аппаратуры не является полным, но он
содержит наиболее популярные и значимые для разрабатываемого проекта языки.

== Промежуточное представление цифровых схем

В силу специфики области разработки аппаратуры, в ней
слабо развиты технологии использования промежуточных представлений,
в сравнении с областью разработки программного обеспечения. В связи
с этим современные языки описания аппаратуры предлагают свои варианты
промежуточного представления.

Основным промежуточным представлением, используемым в области синтеза
цифровых схем является *Netlist*, который представляет собой довольно
примитивное представление соединений операционных элементов схемы.
Открытые средства работы с таким представлением не развиты.

Другим вариантом промежуточного представления может служить сам язык *Verilog*
(или SystemVerilog), который является достаточно низкоуровневым. Для него
имеется обширный набор средства анализа, как проприетарных закрытых, так и
открытых. Однако, этот язык не разрабатывался в качестве промежуточного
представления, из-за чего его обработка и разносторонний анализ
оказываются затруднительны. Тем не менее, некоторые языки используют его
как результат компиляции, например, Verik, о котором упоминялось, язык Chisel
для симуляции схем, SystemC для синтеза.

Еще один подход продемонстрировали разработчики языка Chisel,
представив промежуточное представление *FIRRTL*, которое использует
абстракции языка Chisel и позволяет производить экспорт модели
в виде Verilog. Тем не менее, этот проект является устаревшим
и репозиторий с его исходными кодами объявлен архивным. /*TODO: ссылка на репозиторий */
Разработчиками было принято решение перейти на более гибкую и перспективную
технологию --- LLVM CIRCT.


*LLVM CIRCT* (Circuit IR Compilers and Tools) --- это проект,
направленный на создание инфраструктуры для проектирования цифровых схем с
использованием промежуточного представления (IR). CIRCT базируется на MLIR
(Multi-Level Intermediate Representation), что позволяет использовать модульный
и расширяемый подход к описанию и трансформации цифровых схем. Диаграмма
иллюстрирующая ключевые технологии проекта, взятая с официального сайта,
представлена на рисунке @img:circt-technologies.

#figure(
  image("res/img/circt-technologies.png",
  width: 65%),
  caption: "Ключевые технологии проекта CIRCT, включая связанные сторонние инструменты"
) <img:circt-technologies>

К основным компонентам CIRCT относятся следующие.

- *MLIR*: основа для создания диалектов, которые описывают различные аспекты
  цифровых схем.
- *Диалекты*: включают HW (Hardware), SV (SystemVerilog), FIRRTL и другие,
  которые позволяют описывать схемы на различных уровнях абстракции в зависимости от требований изначального языка.
- *Инструменты трансляции*: такие как `firtool` для преобразования FIRRTL в
  SystemVerilog или диалекты CIRCT.

CIRCT предоставляет мощные возможности для оптимизации и анализа цифровых схем,
а также для интеграции с существующими инструментами проектирования. Так, например,
для языка Chisel разрабатываются диалекты firrtl и cirrtl, которые позволяют
точнее сохранить в семантику языка.

Кроме указаных инструментов, с проектом CIRCT можно рассмотреть отдельные
инструменты для трансляции указанных языков описания аппаратуры в промежуточное
представление диалектов CIRCT. Для языка Verilog разрабатывается современный
фронтенд SVlang, который используется для трансляции утилитой `circt-verilog`.

== Cредства моделирования <средства_моделирования>

Для построения моделей аппаратуры существует множество готовых решений и
подходов, условно их можно разделить на категории: 
- интегрированные решения, предоставляющие обширные возможности по
  разностороннему моделированию,
- простые математические и функциональные модели,
- точные модели, т.н. "cyclic-accurate".

=== Интегрированные решения

Широко распространены интегрированные решения для моделирования,
которые зачастую разрабатываются крупными компаниями --- лидерами
на своем рынке. Сосредоточимся на рассмотрении решений пригодных
для моделирования аппаратуры и программно-аппаратных систем.

// - Modelsim
// - Anylogic
// - MathLab Simulink
// - LabView
// - Engee
// - ...

- *Modelsim* --- популярный инструмент для симуляции цифровых схем. Поддерживает
  Verilog, VHDL и SystemVerilog. Обладает высокой точностью моделирования и
  возможностью интеграции с другими инструментами проектирования. Стоимость
  лицензии может быть высокой, что делает его доступным в основном для крупных
  компаний.

- *MATLAB Simulink* --- развитый инструмент для моделирования и симуляции систем.
  Поддерживает генерацию HDL через дополнительные модули. Хорошо интегрируется с
  другими инструментами MATLAB. Стоимость лицензии высокая, но инструмент
  популярен в академической и инженерной среде.

- *LabVIEW* --- инструмент для визуального программирования и моделирования.
  Подходит для управления оборудованием и симуляции. Генерация HDL возможна через
  дополнительные модули. Стоимость лицензии высокая, но инструмент широко
  используется в промышленности.

- *Engee* --- российская среда динамического моделирования и технических расчётов.
  Интрумент предоставляет возможности по моделированию систем как с помощью
  визуального программирования функциональными блоками, так и с применением
  языка программирования Julia. На официальном сайте представлены примеры
  использования системы для генерации кода на языке Verilog. /* TODO: ссылка на
  канал в тг */

- *Quartus Prime* --- инструмент от Intel для проектирования FPGA. Поддерживает
  генерацию HDL и интеграцию с аппаратными платформами. Бесплатная версия
  доступна, но с ограничениями. Популярен среди разработчиков FPGA.

- *Vivado* --- инструмент от Xilinx для проектирования FPGA. Поддерживает
  генерацию HDL и интеграцию с аппаратными платформами. Бесплатная версия
  доступна, но с ограничениями. Широко используется в индустрии.

Каждое из этих решений имеет свои особенности, и выбор зависит от требований
проекта, бюджета и уровня интеграции с существующими системами. Но все они так
или иначе используют язык Verilog (SystemVerilog) как промежуточное
представление для моделей и высокоуровневого синтеза. Эти решения являются
проприетарными и у них ограниченные возможности по интеграции разработанных
моделей в сторонние системы.

=== Mатематические модели

Другим подходом к моделированию является математическое моделирование c
применением т.н. передаточных функций. Основные качества подхода с
использованием передаточных функций:

- *простота* --- передаточные функции предоставляют компактное и удобное
  представление системы в виде алгебраического выражения, поддающегося
  обыкновенным методам математического анализа,

- *точность* --- при правильной настройке передаточные функции могут точно
  описывать поведение системы в определенных условиях, однако точность зависит
  от уровня абстракции и предположений, сделанных при создании модели,

- *эффективность* --- математические модели, как правило, обладают высокой
  вычислительной эффективностью, так как они оперируют упрощенными представлениями
  системы, что позволяет значительно сократить время расчетов, математические
  модели могут быть выполнены быстрее за счет использования аналитических
  методов и упрощений,

- *ограничения* --- математическим моделям свойственно не учитывать всех
  деталей и нюансов работы реальных устройств, они ведут себя как эталонная
  реализация, что мешает проводить сквозное тестирование системы с
  использованием таких моделей.

Таким образом, подход с использованием передаточных функций является мощным и
удобным инструментом для моделирования приборов, при модульном, функциональном
и интеграционном тестировании, но не подходит для целей сквозного тестирования.

=== Точное моделирование

// Icarus Verilog, Verilator, Quartus, Vivado,...
// Qucks(?)

Точное моделирование популярно в сфере разработки аппаратуры. И многие
интегрированные решения, в том числе описанные ранее, обладают такими
возможностями. Однако, их использование в открытом проекте затруднительно.
Среди свободных решений для точного ("cyclic-accurate") моделирования можно
выделить следующие.

SystemC, как уже говорилось ранее, подходит для создания моделей систем, он
также позволяет производить точное моделирование работы аппаратных модулей и
использует собственную реализацию операционного окружения для этого. В
результате компиляции проекта на SystemC получается исполняемый файл, который
при запуске выполняет симуляцию работы системы. SystemC предоставляет
возможность для интеграции с итоговыми моделями системы, но всё таки этот подход
выглядит трудоемким. /* TODO ссылки на доку */

*Icarus Verilog* --- это бесплатный инструмент для симуляции Verilog. Подходит для
небольших проектов и обучения. Он очень ограничен в функциональности и
возможности интеграции с ним. /* TODO ссылка на сайт */

*Verilator* --- это бесплатный инструмент с открытым исходным кодом для симуляции
Verilog. Инструмент позволяет транслировать код на языке Verilog в код на языке
C++. В результате компиляции полученных исходных кодов на языке C++ получается
исполняемый файл, который выполняет высокопроизводительное точное моделирование
работы аппаратного модуля. Как и в случае с SystemC, инструмент предлагает
интерфейс для взаимодействия с итоговыми моделями, который выглядит сложным для
использования этого решения во внешней системе. Verilator является популярным
решением в своей сфере и активно развивается, например, язык Chisel использует
этот инструмент для симуляции работы разработанной модели.

*Arcilator* --- это инструмент в составе проекта CIRCT, предназначенный
для анализа и оптимизации цифровых схем и представляющий собой утилиту командной
строки `arcilator`. Он предоставляет возможности для трансформации и
симулирования работы цифровых схем, описанных на различных уровнях абстракции с
использованием ключевых диалектов MLIR из проекта CIRCT.

Инструмент позволяет конфигурировать процесс трансляции промежуточного
представления CIRCT в промежуточное представление LLVM, в зависимости от
требований к нативной модели, например, можно указать опции, добавляющие
возможность наблюдения за внутренними состояниями аппаратного модуля, что может
быть важно при его тестировании и отладке.

Так же немаловажным является то, что итоговая модель представляет собой функцию,
которая получает старое состояние модели и обновляет его в соответствии с
логикой работы устройства, т.е. не содержит дополнительной среды выполнения, с
которой пришлось бы взаимодействовать, а просто поддерживает ABI. Такая
особенность инструмента позволяет использовать его из внешних систем, например,
загружая скомпилированный модуль динамически с любым наперед неизвестным
количеством приборов: нужно лишь создать структуру состояния для каждого.


== Способы взаимодействия с внешним кодом

// === JNI
// === IPC
// === Kotlin/Native
// === FFM API
// ==== Описание

// ==== Использование FFM API

// - Jextract
// - Прямое использование FFM API
// - Собственные обертки FFM API
// - Проект Java Native Memory Access

Область применения фреймворка определяет основную целевую платформу
разрабатываемого решения --- JVM. А средства симуляции предоставляют модели в
виде нативных модулей. Поэтому важно найти способ взаимодействия между этими
компонентами.

Интеграция с нативным кодом из Kotlin/JVM может быть выполнена различными
способами, в зависимости от требований проекта и используемых технологий.


*JNI* (Java Native Interface) --- технология платформы JVM предоставляющая
стандартный способ взаимодействия между Java (и Kotlin/JVM) и нативным кодом,
написанным на C или C++. Этот подход позволяет вызывать нативные функции из JVM
и наоборот.
- Преимущества.
  + Широкая поддержка и документация.
  + Возможность работы с любыми библиотеками на C/C++.
  + Доступно на старых версиях JDK.
- Недостатки.
  + Требует написания кода на C/C++ обрабатывающего нативные вызовы.
  + Требует ручного управления памятью.


*IPC* (Inter-Process Communication) --- межпроцессное взаимодействие
используется для взаимодействия между процессами, когда нативный код выполняется
в отдельном процессе. Это может быть полезно для повышения безопасности и
изоляции.

- Преимущества.
  + Изоляция процессов повышает стабильность.
  + Подходит для взаимодействия с нативными сервисами.
- Недостатки.
  + Более высокая задержка из-за межпроцессного взаимодействия.
  + Сложность настройки.


*Kotlin/Native* позволяет компилировать Kotlin-код в нативный бинарный код, что
упрощает взаимодействие с нативными библиотеками. Это особенно полезно для
мультиплатформенных проектов.

- Преимущества:
  + Естественная интеграция с Kotlin.
  + Существуют инструменты автоматизирующие интеграцию с JVM.
- Недостатки:
  + Ограниченная поддержка JVM-специфичных функций.
  + Такие же сложности как и с обыкновенным JNI.
  + Требует использования среды исполнения Kotlin/Native.

// === FFM API (Foreign Function & Memory API)

*FFM API* — это современный способ взаимодействия с нативным кодом,
официально предоставляемый в JDK, начиная с версии 22. Он позволяет работать с
внешней памятью и вызывать внешние функции без использования JNI.

- Преимущества:
  + Повышенная производительность.
  + Упрощенная работа с нативной памятью.
- Недостатки:
  + Требует использования последних версий JDK.

Прямое использование FFM API позволяет вручную вызывать нативные функции и
управлять памятью, но в силу особенностей языка Java требуется довольно много
дополнительного программного кода.

Проект Panama по развитию возможностей работы с внешним кодом в JVM, частью
которого является FFM API, предоставляет дополнительный инструментарий для
повышения удобства работы с нативными библиотеками.

*Jextract* --- инструмент для автоматической генерации кода на языке Java,
выполняющего обращение к нативным библиотекам. В качестве основы он берет
имеющиеся заголовочные файлы на языке C. Код, генерируемый этим инструментом,
оказывается громоздким и плохо читаемым, и поэтому инструмент лучше всего
подходит в тех случаях, когда нужно автоматически адаптировать большое
количество кода, что не получится сделать эффективно другими средствами.

Так же существуют решения от сторонних разработчиков, позволяющие автоматически
генерировать код для работы с FFM API на базе аннотаций --- проект *Java Native
Memory Access*. /* TODO ссылка */ Это решение так же полагается на наличие
заголовочного файла на языке C, описывающего интерфейс работы с нативным
модулем.

Каждый из описанных подходов имеет свои особенности, и выбор сильно зависит от
требований проекта и сценариев использования.

= Проектирование решения

В этой главе описываются процесс выявления требований к проекту, анализ этих
требований и архитектурные решения о выборе используемых для реализации проекта
технологий.

== Требования к проекту <требования_к_проекту>

Со стороны разработчикой фреймворка "Controls.kt" не выдвигалось явных требований
к реализации модуля моделирования аппаратуры. Тем не менее, исходя из
направленности фреймворка и общих представлений о разработке аппаратуры, 
разработчики дали следующие рекомендации.

+ Программному модулю следует использовать промежуточное представление цифровых
  схем для создания моделей.
+ Программный модуль следует сделать проектом, отдельным от "Controls.kt".

Первая рекомендация говорит о том, что программный модуль должен использовать
промежуточное представление как интерфейс для возможности интегрироваться с ним.
//
Вторая рекомендация говорит о том, что программному модулю не следует добавлять
зависимость на "Controls.kt", ведь он может быть полезен в отрыве от фреймворка.

Исходя из этих рекомендаций и свойств целевой области применения были
сформулированы следующие требования к программному модулю.

1. Программный модуль должен быть разработан на языке программирования Kotlin. 
2. Программный модуль должен следовать принципам мультиплатформенной разработки
   на языке Kotlin.
3. Программный модуль должен предоставлять абстракции для работы с моделями
   аппаратуры.
3. Программный модуль должен использовать промежуточное представление для
   описания аппаратуры. 
4. Программный модуль должен генерировать код на языке Kotlin для использования
   конкретных моделей аппаратуры на базе промежуточного представления.
5. Программный модуль должен давать возможность конфигурации процесса генерации
   кода.

Первое требование отвечает ключевой технологии с помощью которой реализован
фреймворк "Controls.kt". Язык Kotlin выбран сознательно, так как это современный
язык программирования, предоставляющий простой интерфейс взаимодействия с JVM
платформой и обладающий большей выразительностью в сравнении с языком Java.
Закономерно выдвинуто второе требование: целевой фреймворк следует принципам
мультиплатформенной разработки и есть потенциал реализовать проект с поддержкой
платформ отличных от JVM, например, Native или WASM.

Третье требование отвечает первоначальной рекомендации; четвертое требование
является осмысленным по той причине, что промежуточного представления вполне
достаточно для автоматического определения интерфейса взаимодействия с
моделируемым устройством, и создание корректного программного интерфейса
является сложной задачей для человека. Пятое требование призвано добавить гибкости
в генерации кода, что должно позволить расширить возможности по использованию
полученных программных моделей и удобство структурирования проекта
разрабатываемой системы.

Готовые решения для моделирования, такие как Modelsim, LabVIEW и другие
описанные в разделе @средства_моделирования про средства моделирования, решено
не использовать по той причине, что они являются проприетарными, не дают
требуемой гибкости в создании и использовании моделей, и их использование
приведет к ограничению возможностей по расширению разрабатываемого программного
решения, например, в сторону использования стороннего средства моделирования.

В соответствии с описанными требованиями был определен набор технологий для
реализации проекта.

== Обзор выбранных технологий

Было принято решение разработку программного модуля вести в отдельном
репозитории в интернет-сервисе GitHub и дать проекту название "Circulator".

Сборка проекта происходит с использование инструмента Gradle, так как он 
рекомендуется в официальной документации к языку Kotlin для мультиплатформенных
проектов. По той же причине этот инструмент выбран для реализации компонента
выполняющего генерацию кода: компонент должен иметь возможность встраиваться в
сборочный процесс. Непосредственно для генерации кода используется программная
библиотека Kotlin Poet, которая предоставляет программный интерфейс для
управления процессом генерации кода.

В качестве промежуточного представления принято решение использовать семейство
диалектов MLIR описанных в проекте CIRCT по той причине, что проект активно
развивается и такое промежуточное представление является наиболее гибким для
анализа, оптимизаций и другой обработки с помощью открытых компиляторных
технологий из проекта LLVM.  Кроме того, имеются или находятся в разработке
инструменты для получения этого промежуточного представления из популярных
языков описания аппаратуры вроде SystemVerilog и Chisel.

Для получения нативной модели из промежуточного представления используется
инструмент Arcilator, так как он предоставляет готовый пользовательский
интерфейс для использования набора преобразований необходимых для получения
LLVM IR из CIRCT IR, который далее используется для компиляции в нативный
код либо статической, либо динамической библиотеки. Этот инструмент выбран
в большей степени в силу своей простоты использования, но он не является
критичным для реализации; Arcilator вполне можно заменить на другие инструменты
предоставляющие возможность получения нативных моделей из описания аппаратуры,
например, более популярный Verilator или SystemC, но они не рассчитаны на работу
с промежуточным представлением, из-за чего очень специализированны для
конкретного языка описания аппаратуры и, кроме того, влекут использование их
собственной среды исполнения с усложненным ABI.

Компиляция LLVM IR в нативный код можно использовать стандартные инструменты
проекта LLVM, лучше всего для этого подходит драйвер clang, который
предоставляет пользовательский интерфейс для работы с другими утилитами,
такими как оптимизатор и компилятор LLVM IR. Также он позволяет сразу получить
нативные модели в виде динамически загружаемых библиотек.

Взаимодействие с нативным кодом может происходить различным образом,
в зависимости от требований проекта и платформы, используемой для
реализации системы. Так как фреймворк "Controls.kt" в основе своей
нацелен на использование платформы JVM, в разрабатываемом решении
так же сделан упор на эту платформу.

Для обращения из JVM к нативному коду моделей принято решение использовать FFM
API, так как он является наиболее современным и производительным. Эта технология
в большей степени выбрана в силу своей простоты с точки зрения использования, но
она не является критичной. Для ее удобного использования решено было реализовать
слой абстракций, реализующих логику работы с внешним кодом и предоставляющих
упрощенный программный интерфейс; эта разработка оказывается оправданна, так как
Arcilator предоставляет стабильный ABI и для готовых инструментов требуется
наличие заголовочных файлов на языке C.

Тогда общий принцип получения программных моделей на базе языка описания аппаратуры
состоит в следующем.

1. Трансляция языка описания аппаратуры в промежуточное представление.
2. Обработка и анализ промежуточного представления с дальнейшей компиляцией его в LLVM IR.
3. Генерация программного кода на языке Kotlin на основе полученного анализа.
4. Подключение нативных библиотек реализующих логику работы устройств к системе.

Таким образом, для реализации проекта выбраны технологии, которые позволяют
выполнить поставленные требования наиболее оптимально для его целевой области
применения.

= Обзор разработанного решения

В этой главе описывается реализация разработанного инструмента "Circulator" до
версии 0.1.0 включительно. Также в ней описываются условия и примеры его
использования для проведения сквозного тестирования.

Проект выполнен в соответствии с принципами мультиплатформенной разработки на
языке Kotlin и представляет собой программную библиотеку и плагин для системы
сборки Gradle. Проект структурирован как композитный проект в системе сборки
Gradle и содержит следующие модули.

- `circulator-core` --- ядро проекта, включаемое во все подпроекты Circulator.
  Оно реализуется как программная библиотека, предоставляющая абстракции для
  описания и использования моделей аппаратуры, а так же структуры данных для
  работы со средствами моделирования (Arcilator для указанной версии).
- `circulator-plugin` --- реализация плагина для системы сборки Gradle. Он
  принимает конфигурацию из сценария сборки, допольнительно конфигурирует проект и
  генерирует код на языке Kotlin.
- `demo` --- проект с подпроектами, демонстрирующими возможности использования
  инструмента.

== Общая архитектура проекта

Модуль `demo` включает в свой процесс сборки корневой проект, что важно для
использования актуальной версии плагина выполняющего генерацию кода. Несмотря на
неочевидную зависимость подпроектов, такая конфигурация сборочного
процесса оказывается удобной во время разработки, так как при использовании
демонстрационного проекта в качестве корневого, среда разработки и система
сборки правильно решает зависимости.

Визуализация размещения модулей представлена на диаграмме
@img:circulator-project-struct. Пунктиром на ней изображены
подмодули отвечающие за конкретную платформу, а стрелки указывают направление зависимости.

#figure(
  image("res/img/circulator-project-struct.png"),
  caption: "Диаграмма структуры проекта Circulator, иллюстрирующая зависимости между модулями"
// - диаграмма размещения
) <img:circulator-project-struct>

Центральный модуль проекта `circulator-core` предоставляет базовые абстракции для
создания модели прибора:

- класс `Model` для определения интерфейса для работы с моделью прибора,
- и класс `ModelLibrary` для определения интрефейса для работы с нативной
  библиотекой,
- классы делегатов для получения внутреннего состояния прибора, следующие
  интерфейсу `StateProjection<T>`.

Диаграмма классов, визуализирующая взаимосвязь между компонентами, представлена
на рисунке @img:circulator-core-class-diagram. Классы реализцющие интерфейс
`StateProjection<T>` выполняют доступ к данным, расположенным во внешней помяти
по отношению к куче JVM, и к ним делегируется обращение к свойствам класса
модели. Для примитивных типов таких, как Byte, Int, Long и пр., отдельно
реализованы классы, потому, как доступ к сегменту памяти происходит не
полиморфным, а зависимым от типа, образом.

#figure(
image("res/img/circulator-core-class-diagram.svg"),
caption: "Диаграмма ключевых классов, лежащих в основе Circulator"
) <img:circulator-core-class-diagram>

Указанные классы оказываются сильно зависимыми от платформы JVM, так как
полагаются на пакет `java.lang.foreign` для работы с нативным кодом. В
результате, в мультимлатформенной части проекта оказывается класс определяющий
схему данным для работы с утилитой `arcilator` и базовый набор типов состояний,
наблюдаемых в модели.  При дальнейшем развитии проекта предполагается реализация
обобщенного мультиплатформенного подхода для определения классов моделей, что
так же может быть полезно для использования с другими инструментами для создания
нативных моделей.

// === Принцип работы модели

Модель устройства содержит сегмент памяти, внешней для кучи JVM, в котором
сохраняется состояние модели. Размер этого сегмента берется из конфигурации.
Обращение к этому сегменту происходит через делегаты следующие интерфейсу
`StateProjection<T>`, параметризованного типом данных, представленного в
проекции состояния.

Для каждого стандартного типа проекции, унаследованного из проекта Arcilator,
имеется соответствующая функция-конструктор, общий вид сигнатуры которых можно
видеть на листинге @lst:state-projection-delegates. Такая функция позволяет
указать номер байта в сегменте памяти, соответствующего началу данных отвечающих
данной проектции. Используя эти функции получается компактно определить
интерфейс модели --- геттер и сеттер свойства класса соответствующие проекции
состояния делегируются объекту полученному из функции примерно так: `var clock
by input<Byte>(0)`.

#figure(
```kotlin
fun <T> Model.input(offset: Long) = // ...
fun <T> Model.output(offset: Long) = // ...
fun <T> Model.register(offset: Long) = // ...
fun <T> Model.memory(offset: Long, layout: /* ... */) = // ...
fun <T> Model.wire(offset: Long) = // ...
```,
caption: "сигнатура функций использующихся для создания проекций состояния"
) <lst:state-projection-delegates>

Соответственно количеству бит для хранения значения в проекции состояния,
указанному в конфигурации, используется наименьший по размеру тип языка Kotlin
допускающий весь диапозон значений. Соответствие типов можно видеть в таблице
@tab:bit_to_type_translation.

#figure(
  table(
    columns: 2,
    align: (center, left),
    [*Количество бит*], [*Тип Kotlin*],
    "(0; 8]",    [UByte],
    "(8; 16]",   [UShort],
    "(16; 32]",  [UInt],
    "(32; 64]",  [ULong],
  ),
  caption: [Соответствие типов данных при генерации кода]
) <tab:bit_to_type_translation>

После изменения значения свойства объекта необходимо выполнить рассчет нового
состояния модели, вызвав метод `eval()`. Последовательность операций
производимых в системе можно представить в виде диаграммы на рисунке @img:circulator-usage-sequence.


/*
```mermaid
---
config:
  look: classic
---
sequenceDiagram
    participant S as Система<br/>управления
    participant M as Модель
    participant L as Библиотека<br/>модели
    participant DL as Динамическая<br/>библиотека
    loop
        S->>M: записи значений в свойства
        S->>M: 
        S->>M: вызов eval()
        activate M
        M->>L: 
            L->>DL: вызов функции
            activate DL
            deactivate DL
            DL->>L: 
        L->>M: 
        M->>S: считывание обновленных<br/>значений свойств
        M->>S: 
        deactivate M
    end
```
*/
#figure(
image("res/img/circulator-usage-sequence.svg"),
caption: [Диаграмма последовательности выполнения операций при работе с
моделью]
// - диаграмма последовательности взаимодействия с моделью
) <img:circulator-usage-sequence>

== Архитектура плагина

Плагин для сборочной системы Gradle является ключевой действующей фигурой из
состава разрабатываемого инструмента, именно плагин выполняет необходимые действия
для получения рабочей модели устройства. Процесс работы с плагином состоит из
следующих этапов.

+ Конфигурация плагина.
+ Компиляция языка описания аппаратуры.
+ Генерация кода.
+ Использование полученной модели.

Для каждого этапа были проработаны нюансы его прохождения и разработана методика
действий; все они нашли отражение в архитектуре плагина.

=== Конфигурация

Конфигурация плагина производится через интерфейс системы сборки Gradle, то есть
в файле конфигурации `build.gradle.kts`, который находится в корне проекта
подлежащего сборке, согласно документации Gradle.

Плагин необходимо подключить в процесс сборки, указав его идентификатор в
соответствующей секции файла конфигурации, то есть так, как показано на листинге
@lst:plugin_install.

#figure(
```kotlin
plugins {
    // ... other plugins
    id("io.github.e1turin.circulator.plugin") version "0.1.0"
}
```,
caption: [Подключение плагина в системе сборки Gradle]
) <lst:plugin_install>

Плагин принимает конфигурацию в секции своего расширения так, как это показано
на листинге @lst:circulator-config. Конфигурация плагина сознательно вынесена в
отдельный файл, потому что она может выглядеть громоздко в конфигурации сборки
проекта, а так же такое решение позволяет разделить конфигурации моделей и
проекта.

#figure(
```kotlin
circulator {
    config = file("src/jvmMain/resources/circulator/config.json5")
}
```,
caption: [Настройка плагина Circulator в секции расширения]
) <lst:circulator-config>

Cхема данных конфигурации плагина ссылается на формат
файла состояний утилиты `arcilator`. Файл можно получить запустив `arcilator`
для модели в формате CIRCT IR с флагом `--state-file`, указав
путь до выходного файла так, как это показано на листинге @lst:arcilator-command.
Этот файл содержит описание характеристик модели полученной на вход утилиты.
Пример содержимого файла представлен на листинге в приложении Б/* @lst:arcilator-state-file*/.

#figure(
```sh
arcilator --state-file=states.json --emit-llvm -o counter.ll counter.mlir
```,
caption: [ Пример использования утилиты `arcilator` ]
) <lst:arcilator-command>


Формат файла не задокументирован и для того, чтобы понять его формат, потребовалось
/* изучить примеры использования утилиты для получения VCD файла с симуляцией работы
устройства /* TODO ссылка */ и */ исходный код утилиты/* TODO ссылка */. В
результате были выяснена схема данных этого файла, которая зафиксирована в файле
`ArcilatorStateFileSchema.kt` и `StateProjectionType.kt` проекта Circulator с
использованием типов данных Kotlin. Cодержимое указанных файлов можно видеть на
листингах @lst:ArcilatorStateFileSchema.kt и @lst:StateProjectionType.kt
соответственно.

#figure(
include "res/code/ArcilatorStateFileSchema.kt.typ",
caption: [ Классы на языке Kotlin, определяющие схему данных файла состояний Arcilator ] /* TODO*/
) <lst:ArcilatorStateFileSchema.kt>


Формат файла состояний содержит следующие важные атрибуты.

- `name` в описании модели --- название модели.
- `numStateBytes` --- размер структуры в байтах, используемой для хранения состояния.
- `initialFnSym`, `finalFnSym` --- название символов в выходном LLVM IR модуле
  соответствующих функции инициализации и функции завершения работы модели.
- `states` --- массив содержащий характеристики отдельных проекций состояния
  модели.
- `name` в описании проекции состояния --- название проекции.
- `offset` --- номер байта, начиная с которого располагается значение проекции 
  состояния в структуре состояния произведенной модели в виде LLVM IR.
- `numBits` --- количество бит требующихся для представления всех возможных
  значений проекции состояния.
- `type` --- тип проекции состояния, отвечающий ее назначению.

#figure(
include "res/code/StateProjectionType.kt.typ",
caption: [ Тип перечисления в языке Kotlin, соответствующий типу перечислени в реализации Arcilator ] /* TODO*/
) <lst:StateProjectionType.kt>

В описываемой версии 0.1.0 расширение принимает путь до конфигурация в формате
JSON, в частности JSON5, который позволяет использовать синтаксис для
комментариев. В конфигурационном файле указываются настройки для генерации
моделей отдельных устройств в формате представленном на листинге @lst:circulator-config-file-format/* TODO вынести в приложение */.
Формат JSON выбран среди прочих форматов представления данных как наиболее
популярный и простой для понимания.

#figure(
include "res/code/circulator-config.json.typ",
caption: [Файл конфигурации плагина Circulator]
) <lst:circulator-config-file-format>

Основные элементы формата конфигурации представлены c описанием в следующем
списке.

- `<model_id_name>` --- атрибут с ключом содержащим идентификатор прибора, в
  значении которого находится конфигурация, в версии Circulator 0.1.0 значение
  этого ключа не используется, но в дальнейшем его можно использовать для
  внутренних нужд. Этот атрибут намерено добавлен в значении атрибута `model`,
  а не атрибутом в элементе массива, чтобы гарантировать уникальность
  идентификаторов и иметь возможность в редакторах кода навигироваться по ним.
- `package` --- атрибут cо строковым значением для указания названия пакета,
  в котором необходимо расположить сгенерированный Kotlin-класс.
- `state-file` --- атрибут со строковым значением, содержащим путь до файла
  проекций состояний.
- `all-states-open`, `all-states-mutable`, `all-states-types` --- атрибуты
  отвечающие конфигурации для всех проекций состояний модели сразу. Атрибуты
  соответственно отвечают возможности переопределять это свойство класса,
  записывать в это свойство и набор свойств с фильтрацией по их типу. Значение
  этого атрибута можно переопределить для отдельной проекции состояния с помощью
  следующего атрибута.
- `<state_id_name>` --- атрибут с ключом, содержащим название проекции
  состянияния, и значением, содержащим конфигурацию для генерации её программного
  интерфейса.
- `<var_id_name>` --- атрибут с ключом, содержащим уникальный индентификатор, и
  значением,  на которое можно использовать в конфигурации. На этот атрибут можно
  ссылаться в конфигурации.

Большая часть опций обладает значениями по умолчанию, что позволяет сократить
размер конфигурации и соблюсти логику работы модели, оставив возможность для
изменения, например, по умолчанию все входные порты считаются доступными для
записи, а выходные --- только для чтения.

В рассматриваемой версии Circulator 0.1.0 отсутствует конфигурация для
вспомогательных утилит участвующих в промежуточных этапах получения нативной
модели, потому что это выходит за рамки функциональности разрабатываемого
программного модуля. Эти этапы сильно зависят от конкретных используемых
инструментов и операционной системы, в которой исполняется процесс компиляции.
Тем не менее, в будущих версиях такая конфигурация может стать доступна.

=== Компиляция HDL

Процесс компиляции языков описания аппаратуры в нативный код представляет собой
так же многоэтапный процесс, который протекает независимо от Circulator версии
0.1.0. Плагин в составе Circulator создает зависимость своего этапа генерации кода
на результат протекания процесса компиляции, в частности на выходной файл
состояний утилиты Arcilator.

Можно выделить следующие этапы компиляции, представленные в таблице
@tab:compilation-stages с описанием промежуточных артефактов.

#figure(block(width: 100%)[#v(-2em)],
kind: table,
caption: [Этапы компиляции с их атрибутами]
)<tab:compilation-stages>

#[#show table: set text(size: 12pt)
#table(
  columns: 3,
  row-gutter: (2.2pt, auto),
  table.header([*№*],[*Атрибут*],[*Описание*]),
  table.cell(rowspan: 6)[1],
  [*Название*],
    [Трансляция языка описания аппаратуры в промежуточное представление.],
  [*Вход*],
    [Файл, содержащий исходный код на языке описания аппарутуры.],

  [*Выход*], 
    [Файл, содержащий промежуточное представление в зависимости от исходного
    языка.],

  [*Инструмент*],
    [Компилятор языка, например, плагин компиялтора Scala для Chisel.],
  [*Пример*],
    [Chisel в результате компиляции создает файл `DeviceName.fir` содержащий
    промежуточное представление в виде FIRRTL; альтернативно язык можно сразу
    скомпилировать в промежуточное представление одно из диалектов CIRCT: hw,
    firrtl, или даже SystemVerilog.],

  [*Примечание*],
    [ Для некоторых языков этот этап может быть пропущен, например, Verilog уже
    может считаться своим промежуточным представлением.],
// )
// #table(
//   columns: 3,
  table.cell(rowspan: 6)[2],
  [*Название*],
    [Трансляция промежуточного представления языка в один из основных диалектов CIRCT IR.],
  [*Вход*],
    [Файл, содержащий промежуточное представление языка описания аппаратуры.],
  [*Выход*],
    [Файл, содержащий промежуточное представление на одном из основных диалектов CIRCT IR.],
  [*Инструмент*],
    [Транслятор промежуточных представлений, например, `firtool` или `circt-verilog`.],
  [*Пример*],
    [Промежуточное представление FIRRTL с помощью утилиты `firtool` транслируется в CIRCT IR диалект hw. Описание аппаратуры на языке Verilog с помощью утилиты `circt-verilog` компилируется в hw диалект CIRCT IR.],
  [*Примечание*],
    [Для некоторых языков описания аппаратуры этот этап может быть пропущен, если они уже используют CIRCT IR как промежуточное представление.],
// )
// #table(
//   columns: 3,
  table.cell(rowspan: 6)[3],
  [*Название*],
    [Компиляция CIRCT IR в симуляционную модель в виде LLVM IR.],
  [*Вход*],
    [Файл, содержащий промежуточное представление на одном из основных диалектов CIRCT IR.],
  [*Выход*],
    [Файл, содержащий LLVM IR, соответствующий логике симуляции работы модели, и файл, содержащий характеристики симуляционной модели.],
  [*Инструмент*],
    [Утилита `arcilator`.],
  [*Пример*],
    [Промежуточное представление устройства в виде CIRCT IR диалекта hw с помощью утилиты `arcilator` транслируется в LLVM IR, а с опцией `--state-file=states.json` создается дополнительный файл `states.json`, содержащий характеристики симуляционной модели устройства.],
  [*Примечание*],
    [На этом этапе с помощью отдельных опций можно контролировать процесс трансляции в LLVM IR, отчего будет зависеть набор наблюдаемых состояний в файле характеристики модели.],
// )
// #table(
//   columns: 3,
  table.cell(rowspan: 6)[4],
  [*Название*],
    [Компиляция симуляционной модели в виде LLVM IR в нативный код динамически загружаемой библиотеки.],
  [*Вход*],
    [Файл, содержащий LLVM IR.],
  [*Выход*],
    [Файл динамически загружаемой нативной библиотеки для данной операционной системы.],
  [*Инструмент*],
    [Утилита `clang`.],
  [*Пример*],
    [Файл, содержащий нативный код симуляционной модели в виде LLVM IR, принимается в качестве аргумента утилитой `clang` с опциями для создания динамически загружаемой библиотеки (разделяемой библиотеки). Примеры команд с опциями для популярных операционных систем можно видеть на листинге @lst:llvm-compile-commands.],
  [*Примечание*],
    [Этот этап можно выполнить различным образом, в зависимости от требований к итоговому артефакту: можно выполнить дополнительную серию оптимизаций LLVM IR, можно скомпилировать модель в статическую библиотеку, можно объединить несколько моделей в один нативный модуль и т.д.]
)
]

#figure(
```sh
# Linux
clang -shared -o libcounter.so counter.ll

# Windows with definition file
clang -shared -o counter.dll counter.ll -Wl,/DEF:counter.def
# Windows with manual export
clang -shared -o counter.dll counter.ll -Wl,/EXPORT:Counter_eval

# MacOS
clang -nostartfiles -nodefaultlibs -dynamiclib -o libcounter.dylib counter.ll -lSystem
```,
caption: [Команды для компиляции LLVM IR в динамически загружаемую библиотеку в
зависимости от операц системы]
) <lst:llvm-compile-commands>

Соответственно описанной последовательности этапов, после прохождения третьего
из них появляется файл состояний симуляционной модели, требующийся для генерации
кода на следующем этапе работы с плагином Circulator.

На последнем, четвертом, этапе получается файл динамически загружаемой
библиотеки, который содержит функции, необходимые для работы приложения,
использующего требуемые модели аппаратуры.

=== Процесс генерации кода

Процесс генерации кода заключается в создании файлов с исходным 
кодом на языке Kotlin, реализующих логику взаимодействия с нативными
моделями, полученными на предыдущем этапе работы с плагином Circulator.

Генерация кода начинается с получения конфигурации, описывающей требования
к результирующим моделям, из файла указанного в конфигурации плагина. Далее в
соответствии с ней происходит генерация кода с использованием специализированной
библиотеки Kotlin Poet, предоставляющей программный интерфейс для описания
желаемого кода на языке Kotlin.

При создании свойств генерируемого класса применяется правило именования, при котором
входные и выходные порты называются так же, как задано в конфигурации, а имена
отвечающих за внутреннее состояние свойств начинается с префикса `internal`,
пример сгенерированных свойств можно видеть на листинге
@lst:circulator-state-projection-names. Такой подход позволяет избавиться от
коллизии имен при генерации класса и добавить семантическое обозначение в имя
свойства.

#figure(
```kotlin
  public open var clk: UByte by input<UByte>(0)

  public open var reset: UByte by input<UByte>(1)

  public open val internalClk: UByte by wire<UByte>(2)

  public open val internalReset: UByte by wire<UByte>(3)

  public open val internalReg: UByte by register<UByte>(5)

  public open val internalO: UByte by wire<UByte>(6)

  public open val o: UByte by output<UByte>(7)
```,
caption: [ Пример сгенерированных свойств класса на языке Kotlin ]
) <lst:circulator-state-projection-names>

Плагин Circulator предоставляет дополнительную задачу для системы сборки Gradle,
которая находится в группе задач "circulator" и называется "generateKotlinClasses",
что можно видеть на листинге @lst:circulator-gradle-task-group. При конфигурации
проекта плагин добавляет этой задаче зависимость от файла конфигурации и файлов
указанных в файле конфигурации, что позволяет отслеживать изменения в
используемых артефактах предыдущих этапов.

#figure(
include "res/code/circulator-gradle-task-group.typ",
caption: [ Вывод утилиты `gradle` со списком задач в группе "circulator" ]
) <lst:circulator-gradle-task-group>

Для удобства работы с плагином можно описать этапы компиляции HDL с помощью
отдельных задач системы сборки Gradle и добавить задаче "generateKotlinClasses"
зависимость на них так, как это показано для примера с Chisel на листинге
@lst:circulator-compilation-pipeline-setup. Подобным образом можно
сконфигурировать процесс сборки с другим языком описания аппаратуры. 

#figure(
```kotlin
/* in subproject 'chisel' */
val compileChisel = tasks.register<JavaExec>("compileChisel") {
  /* ... */
}
val compileFirrtl = tasks.register<Exec>("compileFirrtl") {
    dependsOn(compileChisel) /* ... */
}
val compileCirctMlir = tasks.register<Exec>("compileCirctMlir") {
    dependsOn(compileFirrtl) /* ... */
}
val compileLlvm = tasks.register<Exec>("compileLlvm") { 
    dependsOn(compileCirctMlir) /* ... */ 
}
val runFullPipeline = tasks.register("runChiselPipeline") {
    dependsOn(compileLlvm) /* ... */
}

/* In parent project */
tasks.named("generateKotlinClasses") {
    dependsOn(":chisel:runChiselPipeline")
}
```,
caption: [ Пример конфигурации процесса компиляции в сборочной системе Gradle ]
) <lst:circulator-compilation-pipeline-setup>

В случае использования плагина с языком Chisel в одном проекте есть нюанс
связанный с последовательностью выполнения стандартных для Gradle задач ---
возникает ошибка из-за циклической зависимости задач. Дело в том, что
язык Scala, который используется в основе компилятора Chisel зависит от
Java классов, которые получаются, в том числе, в результате компиляции
классов Kotin. Но компиляция Kotlin в силу использования плагина Circulator
начинает зависеть от компиляции Chisel, и образуется циклическая зависимость
"Kotlin --- Chisel --- Scala --- Kotlin". Наиболее простой способ решить эту
проблему состоит в том, чтобы сделать отдельный проект, отвечающий за компиляцию
Chisel, а в проект использующий плагин Circulator добавить зависимость на
результат исполнения его задачи, что продемонстированно на листинге /* TODO */.
Такой подход решает еще и проблемы возникающие при одновременном использовании
плагина Scala и Kotlin Multiplatform для системы сборки Gradle в одном проекте.

== Использование модели

После выполненной генерации кода классы Kotlin становятся доступны для
использования в программном коде разрабатываемого приложения по имени
пакета, указанного в конфигурации плагина, и имени класса указанному в файле
состояний Arcilator.

// === Пример использования

В качестве основы для демонстрации работоспособности используется модель
счетчика, реализованная на языке описания аппаратуры Chisel, и представленная
на листинге @lst:chisel-counter. В разделе описываются примеры простого
приложения командной строки и более сложного графического приложения,
представляющего прибор интегрированный в простую систему на базе фреймворка
Controls.kt.

#figure(
```scala
class CounterChisel extends Module {
  val count = IO(Output(UInt(8.W)))
  
  val counter = RegInit(0.U(8.W))
  count := counter

  counter := counter + 1.U
}
```,
caption: [ Модель счетчика на языке Chisel ]
) <lst:chisel-counter>

В обоих примерах создание модели происходит автоматически из описания прибора на
языке Chisel благодаря настроенным задачам и зависимостям между ними, описанными
в разделе про компиляцию HDL. Пример вывода утилиты `gradle`, иллюстрирующего
сборочный процесс можно видеть на листинге @lst:circulator-demo-pipeline.

#figure(
```console
Reusing configuration cache.
...
> Task :sandbox:chisel:compileCounterChisel
> Task :sandbox:chisel:compileFirrtl
> Task :sandbox:chisel:compileCirctMlir
> Task :sandbox:chisel:compileLlvm
> Task :sandbox:chisel:runChiselPipeline
> Task :sandbox:generateKotlinClasses
> Task :sandbox:compileKotlinJvm
> Task :sandbox:compileJvmMainJava
> Task :sandbox:jvmMainClasses
> Task :sandbox:runJvmCounter
Hello JVM World!
...
```,
caption: [ Вывод утилиты `gradle`, демонстрирующий полностью автоматизированный
процесс компиляции и генерации кода ]
) <lst:circulator-demo-pipeline>


=== Условия использования

Для работы с моделью, необходимо выполнить следующие условия.

1. При создании модели должно быть указано *платформонезависимое* имя библиотеки,
   полученной в результате компиляции на предыдущем этапе.
2. Динамическая библиотека должна быть расположена в известных для JVM путях
   файловой системы для поиска библиотек под ее *платформозависимым* именем.
3. При запуске JVM должна быть указана опция, разрешающая доступ к нативной памяти.
4. При создании модели должна быть создана арена внешней памяти соответствующая
   цели использования модели.

Первое условие связано с независимым от платформы (операционной системы)
исполнением кода в JVM, потому как JVM делегирует поиск и загрузку динамической
библиотеки операционной системе, а формат именования таких библиотек на них
отличается.

Второе условие связато с тем, как работает динамический загрузчик библиотек
--- он ищет лишь в определенных путях, в том числе тех, которые указываются при
запуске JVM в свойстве `java.library.path` и/или переменной окружения в
зависимости от операционной системы: `LD_LIBRARY_PATH` на Linux, `DYLD_LIBRARY_PATH` на MacOS. Модель при создании автоматически загружает библиотеку по имени.

/* TODO
- https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/System.html#load(java.lang.String)
- https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/System.html#loadLibrary(java.lang.String)
*/

Третье условие связано с политикой безопасности при работе с FFM API
https://openjdk.org/jeps/472. Спецификация OpenJDK требует указывать опцию
`--allow-native-access` с названием модулей обладающих разрешением.

Четвертое условие связано с поведением JVM при работе с аренам поддерживающих
интерфейс `java.lang.foreign.Arena` в многопоточном приложении. FFM API
предоставляет три вида арен обладающих своими свойствами, одно из которых
возможность доступа из потока отличного от того, на котором арена была создана.
С точки зрения работы моделей приборов, код исполняется в одном потоке
независимо от конкретно типа используемой арены, поэтому если обращаться к
модели из разных потоков, может возникнуть исключение `WrongThreadException`.
Таким образом, нужно либо использовать специальный тип арен доступных из
фабричного метода `Arena::ofShared` интерфейса, либо фиксировать поток, из
которого происходит обращение к модели устройства.


=== Простой пример

В качестве простого примера использования счетчика можно привести тест его
работоспособности: создание объекта модели, инициализация, использование,
проверка количества отсчетов. Исходный код примера приведен на листинге @lst:basic-exmaple.

Аппаратный модуль счетчика реализует функцию подсчета положительных фронтов
входного тактового сигнала. Для моделирования поведения тактового сигнала
используется функция `CounterChiselModel.tick()`, которая циклически сменяет
значение входного сигнала, записывая значения 1 или 0, соответствующие
положительному и отрицательному фронту сигналав, в свойство `clock` модели.

Инициализация счетчика вынесена в отдельную функцию `CounterChiselModel.init()`.
Принцип ее работы соответствует принципу работы системы сброса устройства: на
входной порт необходимо подать логическую единицу и дождаться следующего такта.
Для пущей надежности, как это обычно делают при тестировании дизайнов аппаратных
блоков, до прекращения сброса ожидают несколько тактов.

Так как модель используется в одном потоке, который и создает арену для аллокации
сегмента памяти хранящего состояние модели, создаетсяа рена с ограниченной областью
использования, т.е. с помощью фабричного метода `Arena::ofConfinded`.

#figure(
include "res/code/basic-example.typ",
caption: "Исходный код простого примера, использующего модель счетчика"
) <lst:basic-exmaple>

Основная функция выполняет следующие действия.

+ Создает арену.
+ Создает объект модели счетчика, используя арену.
+ Инициализирует счетчик.
+ Ожидает 10 циклов тактового сигнала.
+ Считывает результат со счетчика.
+ Успешно проверяет результат на равенство ожидаемому значению 10.



=== Пример с Controls.kt <пример_с_Controls.kt>

В качестве более сложного примера использования модели представляется
счетчик в составе прибора на базе фреймворка Controls.kt с графическим
интерфейсом реализованным с использованием фреймворка Compose Multiplatform.
Основные элементы кода реализующего эту систему можно видеть на листинге в
приложении В/*@lst:gui-example*/. Это проект представляет собой модель системы,
которая схематично изображена на рисунке @img:demo-gui-scheme.

#figure(
image("res/img/demo-gui-scheme.png", width: 65%),
caption: [Схема зависимости и размещения компонентов в примере простой системы с использованием фреймворка Controls.kt ]
) <img:demo-gui-scheme>

Пример демонстрирует способ интеграции модели прибора из фреймворка Controls.kt
с моделью прибора созданного с помощью Circulator. В примере создается класс,
который реализует интерфейс прибора и определяет спецификацию работы с этим
прибором. Обращения к свойствам и методам модели прибора из Controls.kt
делегируется модели прибора из Circulator, можно найти сходство этого примера с
ранее продемонстрированным простым примером.

По сути, приложение использует прибор, который еще не произведен и имеется лишь
в виде дизайна на языке описания аппаратуры, но уже в таком виде его можно
использовать для построения системы и поиска ошибок в системе. Этот пример,
несмотря на его примитивность, может служить демонстрацией выполнения сквозного
тестирования системы от нажатия на кнопку до отображения счета на экране.

Модель счетчика создается в контроллере посредством менеджера устройств
DeviceManager из Controls.kt, который подключает все устройства в одну систему.
Далее контроллер используется при работе панели управления.

Функция `CounterDeviceController.Panel()` отрисовывает графический интерфейс
приложения, реализующего возможность автоматического и ручного увеличения счета,
а также сброса. Внешний вид этого приложения можно видеть на рисунке
@img:counter-clicker-gui.

#figure(
image("./res/img/counter-clicker-gui.png", width: 65%),
caption: [ Внешний вид графического приложения представляющего систему ]
) <img:counter-clicker-gui>

Во время использования этого приложения было выяснено, что
в системе возникает проблема представления данных: счетчих хранит безнаковое
представление числа, а экран ожидает для отображения число в знаковом
представлении, из-за чего при достижении значения счета 128 происходит знаковое
переполнение и отображается -128, что видно на рисунке
@img:counter-clicker-gui-bug. При этом счетчик напрямую с экраном не
взаимодействует, потому что за передачу данных между компонентами отвечает
контроллер.

#figure(
image("res/img/counter-clicker-gui-bug.png", width: 65%),
caption: [Внешний вид приложения: возникло знаковое переполнение в системе]
) <img:counter-clicker-gui-bug>


Более формально результат тестирования выглядит так:

- *Действие*: нажать кнопку "click" 128 раз.\
- *Ожидаемый результат*: значение счетчика 128.\
- *Фактический результат*: значение счетчика -128.\
- *Проблема*: неверное значение счетчика.\
- *Причина*: знаковое переполнение при отображении значения счетчика.

Простой путь исправление этого недостатка системы заключается в изменении
интерфейса управления экраном: тип входных данных должен допускать полный
диапозон значений счетчика. После использования типа `Int` для входного значения
экрана система работает предсказуемо, и позволяет вести подсчет вплоть до
значения 255 без переполнения, что можно видеть на рисунке
@img:counter-clicker-gui-fix. Таким образом, сквозное тестирование с применением
моделей Circulator позволяет повышать качество разрабатываемых систем, за счет
раннего обнаружения ошибок.

Среди важных нюансов работы моделируемой системы можно отметить, что арена,
используемая для аллокации сегмента памяти внутри модели, получается из
фабричного метода `Arena::ofShared` по той причине, что оба фреймворка,
используемых в примере, работают в многопоточном асинхронном режиме и обращения
к модели устройства происходят из различных потоков. Фиксация потока, о которой
говорится в разделе об условиях использования моделей Circulator, для простоты
примера не производилась. И кроме того, интерфейс приложения оставался отзывчивым
и

#figure(
image("res/img/counter-clicker-gui-fix.png", width: 65%),
caption: [Внешний вид приложения: знаковое переполнение в системе устранено]
) <img:counter-clicker-gui-fix>

= Анализ результатов

В этой главе производится анализ результатов выполнения научно-исследовательской
работы, разработанное решение сравнивается с прочими готовыми решениями и
подходами по достижению поставленной цели, предлагаются варианты использования
инструмента Circulator, и рассматриваются перспективы его развития в будущих
версиях. /* TODO */

== Сравнение с альтернативными решениями

Сравнение разработанного решения Circulator с имеющимися на рынке программными
решениями для моделирования аппаратуры по нескольким ключевым критериям:

- доступность,
- функциональность,
- расширяемость,

#noindent[
  представлено в виде сводной таблицы @tab:circulator-comparison.
]

В первую очередь, Circulator является свободным программным обеспечением,
распространяемым под лицензией Apache 2.0.

Функциональность Circulator в актуальной версии 0.1.0 на порядок меньше, чем у
других программных решений, разрабатываемых компаниями, и пользовательский
интерфейс, в виде программного кода, может быть менее понятен для людей не
знакомых с программированием на языке Kotlin и платформой JVM. Но разработанное
решение отвечает заявленным для него требованиям и целевой аудитории
пользователей.

В силу своей открытости, Circulator обладает возможностью "бесконечного
расширения" функциональности, как обыкновенный программный код, что не
свойственно закрытым проприетарным продуктам, хотя некоторые из них
предоставляют программный интерфейс на одном из языков общего назначения:
Python, Julia, Lua и другие.

Проект Circulator не ограничивается конкретным набором совместимых технологий,
вместо этого он предоставляет API для взаимодействия и полагается на
промежуточное представление. Библиотека совместима с другими проектами, 
работающими на платформе JVM и не обязательно использующими язык Kotlin.

Разработанное решение не стремится заменить имеющиеся решения для создания и
использования моделей аппаратуры, оно занимает позицию между ними и системами
полагающимися на разработанные модели, т.е. Circulator выступает в роли
интегратора готовых дизайнов или моделей аппаратуры в управляющую систему по
типу Controls.kt --- подобного рода "бесконечно расширяемую" систему.
Инструмент нацелен на использование при сквозном тестировании не
аппаратных модулей, а систем, использующих эти модули, что демонстрируется
на примере в разделе @пример_с_Controls.kt.

#figure(
table(
  columns: 3,
  [*Критерий*], 
    [*Circulator*], 
    [*Другие инструменты*], 
  [*Доступность*],
    [Бесплатный и с открытым исходным кодом], 
    [В основном проприетарные с дорогой лицензией], 
  [*Функциональность*],
    [Сфокусирован на интеграции и генерации кода для JVM], 
    [Широкие возможности моделирования и симуляции], 
  [*Расширяемость*], 
    [Высокая расширяемость благодаря открытости кода], 
    [Ограниченная расширяемость, часто привязана к экосистемам поставщиков],
  [*Целевая аудитория*], 
    [Разработчики, использующие Kotlin/JVM],
    [Инженеры и исследователи в области проектирования аппаратуры],
  [*Интеграция*],
    [Бесшовная интеграция с системами на основе JVM],
    [Автономные инструменты с ограниченными возможностями интеграции],
  [*Кривая обучения*], 
    [Требует знаний Kotlin и JVM], [Различается, часто требует специализированных знаний],
  [*Гибкость*],
    [Поддерживает несколько языков описания аппаратуры через промежуточное представление],
    [Часто привязаны к конкретным языкам или фреймворкам], 
),
caption: [Сравнение разработанного решения Circulator с другими решениями]
) <tab:circulator-comparison>

/* сравнение с Jextract/jni/... */

== Способы применения

Применение Circulator по целевому назначению предполагает совместное
использование генерируемых моделей с виртуальными устройствами фреймворка
Controls.kt при выполнении тестовых сценариев. Наличие API на языке Kotlin
позволяет использовать популярные фреймворки для тестирования и современные
подходы такие, как "fuzzing" и "Property-based" тестирование.

Кроме того, можно предложить другой сценарии использования разработанного
инструмента --- верификация готовой модели устройства с помощью сгенерированной
Circulator модели. В таком виде получается производить модульное тестирование
модели устройства.

Среди альтернативных направлений использования Circulator можно увидеть
- разработку учебных демонстрационных моделей устройств,
- модульное и функциональное тестирование дизайна аппаратного модуля
  рядовыми инженерами по автоматизированному тестированию программного обеспечения
- и разработка тестовых сценариев, называемых "testbench", в
  проектах на языке Chisel, с последующим их исполнением.

== Перспективы развития

Реализованная версия 0.1.0 проекта Circulator обладает достаточной
функциональностью для соответствия поставленным ей требованиям, тем не менее
можно рассмотреть возможности для дальнейшего развития проекта. 

Пути развития функциональности проекта связаны с расширением набора технологий
доступных для использования, который сильно ограничен в данной версии, об этом
говорилось в разделе @требования_к_проекту про
требования к проекту. А именно, потенциал развития имеют следующие аспекты.

- Поддержка средств создания нативных моделей и симуляции, отличных от
  Arcilator.  Например, Verilator и SystemC, которые не полагаются на
  промежуточное представление.
- Поддержка других способов взаимодействия с нативными библиотеками. Например,
  JNI или возможности Kotlin/Native.
- Поддержка платформ для запуска моделей, отличных от JVM. Примерами таких
  платформ могут быть Native и WASM.

Также можно рассмотреть варианты добавления в плагин сборочной системы Gradle
возможностей по конфигурированию проектов, направленных на разработку дизайна
аппаратных модулей, и создание входящего в проект Circulator доменно
специфичного языка для описания аппаратных модулей на базе языка Kotlin.

#struct[ЗАКЛЮЧЕНИЕ] <ЗАКЛЮЧЕНИЕ>
// = ЗАКЛЮЧЕНИЕ

В данной работе была описана архитектура и процесс разработки программного
модуля предоставляющего возможности моделирования аппаратуры на уровне цифровых
схем, который применим для использования с виртуальными устройствами фреймворка
Controls.kt.

Разработанный программный модуль Circulator позволяет автоматическим образом
генерировать модели на языке Kotlin из имеющихся моделей устройств,
разработанных на языке описания аппаратуры.

Также в работе был продемонстрирован пример использования инструмента для системы
на базе фреймворка Controls.kt, на котором показано, что цель работы достигнута:
с использованием разработанного решения можно проводить сквозное тестирование
системы для обнаружения недостатков, исправление которых ведет к повышению
качества системы.

Разработанное решение планируется начать использовать в новых проектах
разрабатывающих системы на базе фреймворка Controls.kt. И развитие проекта
Circulator планируется продолжить. Ссылка на личный репозиторий в сервисе
GitHub, где располагается исходный код проекта находится в приложении А.

#struct[СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ] <СПИСОК_ИСПОЛЬЗОВАННЫХ_ИСТОЧНИКОВ>
// = СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ

#struct[ПРИЛОЖЕНИЕ А] <ПРИЛОЖЕНИЕ_А>
// = ПРИЛОЖЕНИЕ A

`https://github.com/e1turin/circulator-kt`

#struct[ПРИЛОЖЕНИЕ Б] <ПРИЛОЖЕНИЕ_Б>
// = ПРИЛОЖЕНИЕ Б

// caption: "" /*TODO*/
// ) <lst:arcilator-state-file>

#include "res/code/state-file.json.typ"

#struct[ПРИЛОЖЕНИЕ В] <ПРИЛОЖЕНИЕ_В>
// = ПРИЛОЖЕНИЕ В

//  caption: "" /* TODO */
// <lst:gui-example>

#include "res/code/gui-example.typ"