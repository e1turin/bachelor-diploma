#import "prelude.typ": *
#import "title-page.typ": title_page

#let title = "Диплом"
#let author = "Тюрин Иван Николаевич"

#show: thesis_format.with(
  title, 
  author, 
  title_page: [
    // no pagebreak as struct alements do so
    #title_page(
      author: author, 
      title: title
    )
  ],
)

// #struct(outlined: false)[СОДЕРЖАНИЕ]
#outline(title: [
  #block(
    inset: (left: 50%),
    align(center)[
      // #set text(14pt)
      СОДЕРЖАНИЕ
    ]
  )
])

//#struct
= ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ

/ Lorem: #lorem(10)

// #struct
= ВВЕДЕНИЕ

При построении сложных систем, немаловажным является вопрос их тестирования, при
этом тестирование с использованием реального оборудования может быть очень
рисковано --- приборы могут быть дорогостоящими или даже уникальными, а выход из
строя хотя бы одного из них приведет к значительным временным потерям, не считая
финансовых затрат. Отсюда возникает необходимость в использовании "виртуальных
устройств", которые создают уровень абстракции между системой управления и
оборудованием, что позволяет незаметно для компонентов системы подменять
реализацию устройства. Например, виртуальное устройство будет имитировать
поведение прибора, но в нужный момент его переключат на реальный прибор.

"Controls.kt" --- это фреймворк на языке программирования Kotlin, разрабатываемый
Центром научного программирования МФТИ. Фреймворк базируется на ядре
фреймворка для работы с данными --- DataForge, который разрабатывался совместно
с подразделением JetBrains Research (https://doi.org/10.1051/epjconf/201817705003). "Controls.kt" предназначен, как заявляют его
авторы, для создания "легковестных" SCADA-систем, его особенность заключается в
том, что он использует асинхронный подход для коммуникации между устрайствами,
что расширяет границы применимости фреймворка. Кроме того фреймворк дает
необходимые абстракции для использования виртульных устройств.

Наиболее известным примером применения "Controls.kt" является установка
использовавшаяся в научном эксперименте по изучению нейтрино, публично
известный, как
#quote([''Troisk nu-mass,, experiment]): https://www.inr.ru/~numass/,
https://doi.org/10.1088/1742-6596/1525/1/012024

В настоящий момент фокус фреймворка сместился в сторону моделирования систем,
примерами чего могут служить демонстрационные проекты в репозитории с исходными
кодами. Перед разработчиками фреймворка встала задача моделирования работы
устройств на уровне цифровых схем, чтобы добиться полного сквозного тестирования
разрабатываемой системы еще до момента изготовления устройства. Такой подход
позволяет повысить качество работы разрабатываемой системы и, возможно, снизить
затраты за счет раннего обнаружения проблем в системе при использовании
конкретной реализации аппаратных компонентов. В данной научной работе 
исследуются пути решения и описывается разработанное решение для задачи
моделирования аппаратуры.

= Проектирование решения
== Требования к проекту

Промежуточное представление

Отдельный проект, Kotlin классы


== Способы описания аппаратных моделей
выбор HDL

=== SystemVerilog

Verilog, SystemVerilog, VHDL
Индустриальные стандарты описания аппаратуры

=== SystemC
Система моделирования с возможностью синтеза описания аппаратуры

=== Chisel
Современный язык описания аппаратуры, основанный на Scala
Chisel - это язык, который позволяет описывать аппаратные схемы на высоком
уровне абстракции, используя функциональный стиль программирования. Он
предоставляет мощные инструменты для создания сложных цифровых систем и упрощает
процесс проектирования. 

Для представления цифровых схем Chisel использует промежуточное представление
аппаратных модулей, так называемое FIRRTL (Flexible Intermediate Representation
for RTL).

На текущий момент проект развивающий FIRRTL объявлен архивным, и разработчики
отсылаются к другой технологии, называемой CIRCT.

=== Verik
Современный язык описания аппаратуры, основанный на Kotlin

== Промежуточное представление цифровых схем
=== Проект LLVM CIRCT

MLIR и ключевые диалекты

=== Транслятор FIRRTL
firtool

=== Транслятор Verilog
circt-verilog

svlang

// #chapter
== Cредства моделирования

=== Индустриальные решения

- Modelsim
- Anylogic
- MathLab Simulink
- ...

=== Передаточные функции

=== Точное моделирование

Icarus Verilog, Verilator, Quartus, Vivado,...
Qucks(?)

Arcilator


== Способы интеграции с нативным кодом

=== JNI
=== IPC
=== Kotlin/Native
=== FFM API
==== Описание

==== Использование FFM API

- Jextract
- Прямое использование FFM API
- Собственные обертки FFM API
- Проект Java Native Memory Access

= Обзор разработанного решения
== Архитектура проекта

диаграмма размещения
диаграмма классов, 
диаграмма последовательности взаимодействия с моделью
мультиплатформа

== Процесс компиляции

конфигурация,

pipeline, описание этапов

скрин `gradle :run`

== Процесс генерации кода

библиотека для генерации кода

== Использование модели

проблема с Arena.ofConfined, фикс Arena.ofShared

пример с Controls

тестирование

= Анализ результатов

== Сравнение с другими решениями
== Способы применения
== Перспективы развития

// #struct
= ЗАКЛЮЧЕНИЕ

// #struct
= СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ

// #struct
= ПРИЛОЖЕНИЕ
