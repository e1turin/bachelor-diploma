#import "prelude.typ": *
#import "title-page.typ": title_page

#let title = "Диплом"
#let author = "Тюрин Иван Николаевич"

#show: thesis_format.with(
  title, 
  author, 
  title_page: [
    // no pagebreak as struct alements do so
    #title_page(
      author: author, 
      title: title
    )
  ],
)

// #struct(outlined: false)[СОДЕРЖАНИЕ]
#outline(title: [
  #block(
    inset: (left: 50%),
    align(center)[
      // #set text(14pt)
      СОДЕРЖАНИЕ
    ]
  )
])

//#struct
= ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ

/ API:
/ ABI:
/ Gradle:
/ HDL:
/ Circulator: название разрабатываемого решения.
/ Native: #lorem(10)
/ Kotlin:
/ Нативные (модели/код): модели/код реализованные на наиболее низкоуровневом языке (для JVM - bin, для wasm - wasm) (от англ. native — "родной") — это машинный код, который выполняется процессором напрямую без дополнительных слоев интерпретации или трансляции. ...
/ Мультиплатформенный: 
/ Сорсет: source set
/ JVM:
/ WASM:
/ Промежуточное представление: внутреннее представление ...
/ CIRCT: 
/ Диалект:
/ CIRCT IR:
/ LLVM:
/ LLVM IR:
/ Фреймворк: 

// #struct
= ВВЕДЕНИЕ

При построении сложных систем, немаловажным является вопрос их тестирования, при
этом тестирование с использованием реального оборудования может быть очень
рисковано --- приборы могут быть дорогостоящими или даже уникальными, а выход из
строя хотя бы одного из них приведет к значительным временным потерям, не считая
финансовых затрат. Отсюда возникает необходимость в использовании "виртуальных
устройств", которые создают уровень абстракции между системой управления и
оборудованием, что позволяет незаметно для компонентов системы подменять
реализацию устройства. Например, виртуальное устройство будет имитировать
поведение прибора, но в нужный момент его переключат на реальный прибор.

Моделирование работы прибора может производиться различными способами, но в любом
случае эта задача требует дополнительных усилий по разработке модели и поддержания
ее актуальности. Кроме того, чем точнее модель и сложнее устройство, тем труднее
ее разработать человеческими усилиями, что серьезно затрудняет или даже делает
невозможным сквозное тестирование модели системы, Если же прибор во время
построения системы находится в разработке, то затраты на поддержание
актуальности модели так же возрастают. 

В данной научной работе исследуются пути решения и описывается разработанное
решение для задачи моделирования аппаратуры.

= Обзор предметной области

// про качество продукта, как межданордный стандарт определяет

== Область применения

Основной целевой областью применения разрабатываемого решения является
аппаратно-программная система, обладающая следующими свойствами:
- поддерживает компонентное моделирование, 
- не требовательная к реальному времени, то есть не критичная к
  производительности моделей,
- поддерживающая разработку на высокоуровневом языке программирования Kotlin или
  другом языке JVM-платформы.

#noindent[
  В частности, такие системы разрабатываются с использованием фреймоворка "Controls.kt".
]

"Controls.kt" --- это фреймворк на языке программирования Kotlin,
разрабатываемый Центром научного программирования МФТИ https://sciprog.center/.
Фреймворк базируется на ядре фреймворка для работы с данными --- DataForge,
который разрабатывался совместно с подразделением JetBrains Research
(https://doi.org/10.1051/epjconf/201817705003). "Controls.kt" предназначен, как
заявляют его авторы, для создания "легковестных" SCADA-систем, его особенность
заключается в том, что он использует асинхронный подход для коммуникации между
устрайствами, что расширяет границы применимости фреймворка. Кроме того
фреймворк дает необходимые абстракции для использования виртульных устройств.

Наиболее известным примером применения "Controls.kt" является установка
использовавшаяся в научном эксперименте по изучению нейтрино, публично
известный, как
#quote([''Troisk nu-mass,, experiment]): https://www.inr.ru/~numass/,
https://doi.org/10.1088/1742-6596/1525/1/012024

В настоящий момент фокус фреймворка сместился в сторону моделирования систем,
примерами чего могут служить демонстрационные проекты в репозитории с исходными
кодами. Перед разработчиками фреймворка встала задача моделирования работы
устройств на уровне цифровых схем, чтобы добиться полного сквозного тестирования
разрабатываемой системы еще до момента изготовления устройства. Такой подход
позволяет повысить качество работы разрабатываемой системы и, возможно, снизить
затраты за счет раннего обнаружения проблем в системе при использовании
конкретной реализации аппаратных компонентов. 

/* TODO: асинхронность */


== Способы описания аппаратных моделей
// выбор HDL

Языки описания аппаратуры (HDL, Hardware Description Languages) играют ключевую
роль в проектировании и разработке цифровых систем. Они позволяют инженерам
описывать поведение и структуру аппаратных компонентов на различных уровнях
абстракции, начиная от логических вентилей и заканчивая сложными системами на
кристалле (SoC). 

Наиболее популярными языками HDL являются Verilog, SystemVerilog, VHDL, SystemC,
Chisel и Verik. Каждый из них имеет свои особенности и области применения:

- *Verilog и SystemVerilog*: Индустриальные стандарты, широко используемые для
  проектирования и верификации цифровых систем. SystemVerilog является расширением
  Verilog и предоставляет дополнительные возможности, такие как
  объектно-ориентированное программирование, интерфейсы и ассерты, что делает его
  мощным инструментом для работы с современными сложными системами.

- *VHDL*: Еще один популярный язык описания аппаратуры, который отличается
  строгой типизацией и высокой читаемостью кода. Он часто используется в
  академической среде и для проектирования систем, требующих высокой надежности.

- *SystemC*: Язык и библиотека на основе C++, предназначенные для
  моделирования аппаратных систем на уровне системного проектирования. SystemC
  позволяет интегрировать моделирование аппаратуры и программного обеспечения, что
  делает его особенно полезным для проектирования встраиваемых систем.

- *Chisel*: Современный язык описания аппаратуры, основанный на языке
  программирования Scala. Chisel предоставляет высокоуровневый функциональный
  подход к проектированию цифровых систем и упрощает процесс разработки за счет
  использования промежуточного представления FIRRTL.

- *Verik*: Новый язык описания аппаратуры, основанный на Kotlin. Verik
  ориентирован на упрощение проектирования цифровых систем и интеграцию с
  современными инструментами разработки.

Каждый из этих языков имеет свои преимущества и недостатки, и выбор подходящего инструмента зависит от конкретных требований проекта, уровня абстракции и предпочтений команды разработчиков.

=== SystemVerilog

// Verilog, SystemVerilog, VHDL
// Индустриальные стандарты описания аппаратуры

SystemVerilog - это современный язык описания аппаратуры, который является
расширением языка Verilog и предназначен для проектирования, моделирования и
верификации цифровых систем. Он был разработан для устранения ограничений
Verilog и добавления новых возможностей, необходимых для работы с современными
сложными системами.

SystemVerilog сочетает в себе возможности описания аппаратуры (HDL) и языков для
верификации (HVL), что делает его универсальным инструментом для проектирования
и тестирования цифровых схем. Он поддерживает такие функции, как:

- *Расширенные типы данных*: SystemVerilog предоставляет богатый набор типов
  данных, включая структуры, объединения, перечисления и динамические массивы, что
  упрощает моделирование сложных систем.
- *Интерфейсы*: Позволяют описывать связи между модулями, упрощая управление
  сложными схемами и улучшая читаемость кода.
- *Ассерты*: Встроенные механизмы для проверки корректности работы системы на
  всех этапах проектирования.
- *Объектно-ориентированное программирование*: SystemVerilog поддерживает
  классы, наследование и полиморфизм, что делает его мощным инструментом для
  создания тестовых сред.
- *Синтаксические улучшения*: Упрощают написание и чтение кода по сравнению с
  традиционным Verilog.

SystemVerilog стал стандартом в индустрии и широко используется для
проектирования сложных цифровых систем, таких как процессоры, системы на
кристалле (SoC) и другие высокопроизводительные устройства. Его популярность
обусловлена мощными инструментами для верификации, такими как UVM (Universal
Verification Methodology), которые позволяют создавать масштабируемые и повторно
используемые тестовые среды.

Таким образом, SystemVerilog представляет собой эволюцию Verilog и VHDL,
объединяя их лучшие черты и добавляя современные возможности для проектирования
и тестирования цифровых систем.

=== SystemC
// Система моделирования с возможностью синтеза описания аппаратуры

SystemC - это язык и библиотека для моделирования аппаратных систем на уровне
системного проектирования. Он предоставляет мощные инструменты для описания и
симуляции сложных цифровых систем, включая возможность моделирования на уровне
транзакций (TLM, Transaction-Level Modeling). SystemC основан на языке
программирования C++ и предоставляет расширения для описания аппаратных
компонентов, таких как модули, процессы, сигналы и порты.

Одной из ключевых особенностей SystemC является его способность интегрировать
моделирование аппаратуры и программного обеспечения в единой среде. Это делает
его особенно полезным для проектирования встраиваемых систем, где требуется
тесная связь между аппаратной и программной частями.

SystemC поддерживает синтезируемые описания, что позволяет использовать его для
генерации аппаратного кода, совместимого с традиционными языками описания
аппаратуры, такими как Verilog или VHDL. Это делает его универсальным
инструментом для проектирования, симуляции и верификации цифровых систем.

Кроме того, SystemC активно используется в индустрии для создания моделей
аппаратуры, которые могут быть использованы для раннего тестирования и
оптимизации систем, что позволяет сократить время разработки и повысить качество
конечного продукта.


=== Chisel
Современный язык описания аппаратуры, основанный на Scala
Chisel --- это язык, который позволяет описывать аппаратные схемы на высоком
уровне абстракции, используя функциональный стиль программирования. Он
предоставляет мощные инструменты для создания сложных цифровых систем и упрощает
процесс проектирования. 

Для представления цифровых схем Chisel использует промежуточное представление
аппаратных модулей, так называемое FIRRTL (Flexible Intermediate Representation
for RTL).

На текущий момент проект развивающий FIRRTL объявлен архивным, и разработчики
отсылаются к другой технологии, называемой CIRCT.

=== Verik
Современный язык описания аппаратуры, основанный на Kotlin

== Промежуточное представление цифровых схем

=== Verilog

=== Netlist

=== FIRRTL
chirrtl

=== CIRCT MLIR

// MLIR и ключевые диалекты

LLVM CIRCT (Circuit IR Compilers and Tools) --- это проект, направленный на
создание инфраструктуры для проектирования цифровых схем с использованием
промежуточного представления (IR). CIRCT базируется на MLIR (Multi-Level
Intermediate Representation), что позволяет использовать модульный и расширяемый
подход к описанию и трансформации цифровых схем.

Основные компоненты CIRCT включают:

- *MLIR*: Основа для создания диалектов, которые описывают различные аспекты
  цифровых схем.
- *Диалекты*: Включают HW (Hardware), SV (SystemVerilog), FIRRTL и другие,
  которые позволяют описывать схемы на различных уровнях абстракции.
- *Инструменты трансляции*: Такие как `firtool` для преобразования FIRRTL в
  Verilog или другие форматы.

CIRCT предоставляет мощные возможности для оптимизации и анализа цифровых схем,
а также для интеграции с существующими инструментами проектирования.

Пример использования CIRCT в контексте моего проекта:

+ *Описание схемы*: Использование FIRRTL для описания цифровых схем на
  высоком уровне абстракции.
+ *Трансляция*: Преобразование FIRRTL в Verilog с помощью `firtool`.
+ *Интеграция*: Использование сгенерированного Verilog-кода в существующих
  инструментах, таких как ModelSim или Vivado, для симуляции и синтеза.

CIRCT также поддерживает разработку пользовательских диалектов, что позволяет
адаптировать его под специфические требования проекта. Это делает его
универсальным инструментом для проектирования и оптимизации цифровых систем.

=== Транслятор FIRRTL
firtool

=== Транслятор Verilog
circt-verilog

svlang

// #chapter
== Cредства моделирования <средства_моделирования>

=== Интегрированные решения

// - Modelsim
// - Anylogic
// - MathLab Simulink
// - LabView
// - Engee
// - ...

- *Modelsim*: Популярный инструмент для симуляции цифровых схем. Поддерживает
  Verilog, VHDL и SystemVerilog. Обладает высокой точностью моделирования и
  возможностью интеграции с другими инструментами проектирования. Стоимость
  лицензии может быть высокой, что делает его доступным в основном для крупных
  компаний.

- *AnyLogic*: Универсальная платформа для моделирования систем. Подходит для
  моделирования сложных процессов, но не предназначена для генерации HDL. Широко
  используется в бизнесе и науке. Стоимость варьируется в зависимости от версии.

- *MATLAB Simulink*: Мощный инструмент для моделирования и симуляции систем.
  Поддерживает генерацию HDL через дополнительные модули. Хорошо интегрируется с
  другими инструментами MATLAB. Стоимость лицензии высокая, но инструмент
  популярен в академической и инженерной среде.

- *LabVIEW*: Инструмент для визуального программирования и моделирования.
  Подходит для управления оборудованием и симуляции. Генерация HDL возможна через
  дополнительные модули. Стоимость лицензии высокая, но инструмент широко
  используется в промышленности.

// - *Engage*: Инструмент для моделирования и симуляции, ориентированный на
//   промышленное применение. Поддерживает интеграцию с существующими системами, но
//   не предназначен для генерации HDL. Доступность и стоимость зависят от региона и
//   версии.
- *Engee*: ...

- *Quartus Prime*: Инструмент от Intel для проектирования FPGA. Поддерживает
  генерацию HDL и интеграцию с аппаратными платформами. Бесплатная версия
  доступна, но с ограничениями. Популярен среди разработчиков FPGA.

- *Vivado*: Инструмент от Xilinx для проектирования FPGA. Поддерживает
  генерацию HDL и интеграцию с аппаратными платформами. Бесплатная версия
  доступна, но с ограничениями. Широко используется в индустрии.

// - *Verilator*: Бесплатный инструмент с открытым исходным кодом для симуляции
//   Verilog. Не поддерживает VHDL. Подходит для высокопроизводительных симуляций, но
//   требует знаний программирования.

// - *Icarus Verilog*: Бесплатный инструмент для симуляции Verilog. Подходит для
//   небольших проектов и обучения. Ограничен в функциональности по сравнению с
//   коммерческими решениями.

Каждое из этих решений имеет свои особенности, и выбор зависит от требований
проекта, бюджета и уровня интеграции с существующими системами.

=== Передаточные функции

Передаточные функции являются мощным инструментом для моделирования приборов и
систем. Они позволяют описывать динамическое поведение системы в частотной
области, что упрощает анализ и проектирование. Основные качества подхода с
использованием передаточных функций включают:

- *Простота*: Передаточные функции предоставляют компактное и удобное
  представление системы в виде алгебраического выражения. Это упрощает анализ,
  особенно для линейных систем, где можно использовать стандартные методы, такие
  как преобразование Лапласа.

- *Точность*: При правильной настройке передаточные функции могут точно
  описывать поведение системы в определенных условиях. Однако точность зависит от
  уровня абстракции и предположений, сделанных при создании модели.

- *Границы применимости*: Передаточные функции наиболее эффективны для линейных
  стационарных систем. Для нелинейных или нестационарных систем их применение
  ограничено, и может потребоваться использование других методов, таких как
  моделирование во временной области или численные методы.

Пример использования передаточных функций в контексте моделирования приборов:

+ *Определение модели*: Определите входные и выходные параметры системы, а также
  динамические свойства, такие как инерция, демпфирование и усиление.
+ *Построение передаточной функции*: Используйте уравнения системы для получения
  передаточной функции, например, в виде отношения полиномов.
+ *Анализ и симуляция*: Используйте передаточную функцию для анализа
  устойчивости, частотных характеристик и переходных процессов. Для симуляции
  можно использовать инструменты, такие как MATLAB Simulink или Python с
  библиотекой Control.

Таким образом, подход с использованием передаточных функций является мощным и
удобным инструментом для моделирования приборов, особенно в случаях, когда
система может быть представлена в линейной форме.

=== Точное моделирование

// Icarus Verilog, Verilator, Quartus, Vivado,...
// Qucks(?)

- *Icarus Verilog*: Бесплатный инструмент для симуляции Verilog. Подходит для
  небольших проектов и обучения. Ограничен в функциональности по сравнению с
  коммерческими решениями.
- *Verilator*: Бесплатный инструмент с открытым исходным кодом для симуляции
  Verilog. Подходит для высокопроизводительных симуляций, но требует знаний
  программирования.
- *Quartus Prime*: Инструмент от Intel для проектирования FPGA. Поддерживает
  генерацию HDL и интеграцию с аппаратными платформами. Бесплатная версия
  доступна, но с ограничениями.
- *Vivado*: Инструмент от Xilinx для проектирования FPGA. Поддерживает генерацию
  HDL и интеграцию с аппаратными платформами. Бесплатная версия доступна, но с
  ограничениями.
- *ModelSim*: Популярный инструмент для симуляции цифровых схем. Поддерживает
  Verilog, VHDL и SystemVerilog. Обладает высокой точностью моделирования и
  возможностью интеграции с другими инструментами проектирования.
- *MATLAB Simulink*: Мощный инструмент для моделирования и симуляции систем.
  Поддерживает генерацию HDL через дополнительные модули.
- *LabVIEW*: Инструмент для визуального программирования и моделирования.
  Подходит для управления оборудованием и симуляции. Генерация HDL возможна через
  дополнительные модули.

Каждое из этих решений имеет свои особенности, и выбор подходящего инструмента
зависит от требований проекта, уровня интеграции с существующими системами и
бюджета.

*Arcilator*

Arcilator - это инструмент в составе проекта CIRCT, предназначенный для
анализа и оптимизации цифровых схем и представляющий собой утилиту командной
строки `arcilator`. Он предоставляет возможности для трансформации и проверки
схем, описанных на различных уровнях абстракции.  Arcilator использует мощь MLIR
для создания модульного и расширяемого подхода к проектированию цифровых систем.
Основные функции включают:

- *Анализ*: Проверка корректности схем и выявление потенциальных ошибок.
- *Оптимизация*: Улучшение производительности и уменьшение размера схем.
- *Интеграция*: Возможность взаимодействия с другими инструментами CIRCT.

Arcilator является важным компонентом экосистемы CIRCT, предоставляя
разработчикам мощные инструменты для работы с цифровыми схемами.


== Способы взаимодействия с нативным кодом

// === JNI
// === IPC
// === Kotlin/Native
// === FFM API
// ==== Описание

// ==== Использование FFM API

// - Jextract
// - Прямое использование FFM API
// - Собственные обертки FFM API
// - Проект Java Native Memory Access

Интеграция с нативным кодом из Kotlin/JVM может быть выполнена различными
способами, в зависимости от требований проекта и используемых технологий.
Рассмотрим основные подходы:

=== JNI (Java Native Interface)

JNI предоставляет стандартный способ взаимодействия между Java (и Kotlin/JVM) и
нативным кодом, написанным на C или C++. Этот подход позволяет вызывать нативные
функции из JVM и наоборот.

- *Преимущества*:
  - Широкая поддержка и документация.
  - Возможность работы с любыми библиотеками на C/C++.
- *Недостатки*:
  - Сложность написания и отладки кода.
  - Требует ручного управления памятью.

=== IPC (Inter-Process Communication)

IPC используется для взаимодействия между процессами, когда нативный код
выполняется в отдельном процессе. Это может быть полезно для повышения
безопасности и изоляции.

- *Преимущества*:
  - Изоляция процессов повышает стабильность.
  - Подходит для взаимодействия с нативными сервисами.
- *Недостатки*:
  - Более высокая задержка из-за межпроцессного взаимодействия.
  - Сложность настройки.

=== Kotlin/Native

Kotlin/Native позволяет компилировать Kotlin-код в нативный бинарный код, что
упрощает взаимодействие с нативными библиотеками. Это особенно полезно для
мультиплатформенных проектов.

- *Преимущества*:
  - Естественная интеграция с Kotlin.
  - Поддержка мультиплатформенности.
- *Недостатки*:
  - Ограниченная поддержка JVM-специфичных функций.
  - Требует использования Kotlin/Native runtime.

=== FFM API (Foreign Function & Memory API)

FFM API — это современный способ взаимодействия с нативным кодом,
предоставляемый в Java. Он позволяет работать с нативной памятью и вызывать
нативные функции без использования JNI.

- *Преимущества*:
  - Высокая производительность.
  - Упрощенная работа с нативной памятью.
- *Недостатки*:
  - Требует использования последних версий Java.
  - API находится в стадии разработки.

==== Использование FFM API

- *Jextract*: Инструмент для автоматической генерации Java-оберток для нативных
  библиотек.
- *Прямое использование FFM API*: Позволяет вручную вызывать нативные функции и
  управлять памятью.
- *Собственные обертки FFM API*: Создание высокоуровневых оберток для упрощения
  работы.
- *Проект Java Native Memory Access*: Расширяет возможности работы с нативной
  памятью.

Каждый из этих подходов имеет свои особенности, и выбор зависит от требований
проекта, уровня производительности и сложности интеграции.

= Проектирование решения

В этой главе описываются процесс выявления требований к проекту, анализ этих
требований и архитектурные решения о выборе используемых для реализации проекта
технологий.

== Требования к проекту <требования_к_проекту>

Со стороны разработчикой фреймворка "Controls.kt" не выдвигалось явных требований
к реализации модуля моделирования аппаратуры. Тем не менее, исходя из
направленности фреймворка и общих представлений о разработке аппаратуры, 
разработчики дали следующие рекомендации.

+ Программному модулю следует использовать промежуточное представление цифровых
  схем для создания моделей.
+ Программный модуль следует сделать проектом, отдельным от "Controls.kt".

Первая рекомендация говорит о том, что программный модуль должен использовать
промежуточное представление как интерфейс для возможности интегрироваться с ним.
//
Вторая рекомендация говорит о том, что программному модулю не следует добавлять
зависимость на "Controls.kt", ведь он может быть полезен в отрыве от фреймворка.

Исходя из этих рекомендаций и свойств целевой области применения были
сформулированы следующие требования к программному модулю.

1. Программный модуль должен быть разработан на языке программирования Kotlin. 
2. Программный модуль должен следовать принципам мультиплатформенной разработки
   на языке Kotlin.
3. Программный модуль должен предоставлять абстракции для работы с моделями
   аппаратуры.
3. Программный модуль должен использовать промежуточное представление для
   описания аппаратуры. 
4. Программный модуль должен генерировать код на языке Kotlin для использования
   конкретных моделей аппаратуры на базе промежуточного представления.
5. Программный модуль должен давать возможность конфигурации процесса генерации
   кода.

Первое требование отвечает ключевой технологии с помощью которой реализован
фреймворк "Controls.kt". Язык Kotlin выбран сознательно, так как это современный
язык программирования, предоставляющий простой интерфейс взаимодействия с JVM
платформой и обладающий большей выразительностью в сравнении с языком Java.
Закономерно выдвинуто второе требование: целевой фреймворк следует принципам
мультиплатформенной разработки и есть потенциал реализовать проект с поддержкой
платформ отличных от JVM, например, Native или WASM.

Третье требование отвечает первоначальной рекомендации; четвертое требование
является осмысленным по той причине, что промежуточного представления вполне
достаточно для автоматического определения интерфейса взаимодействия с
моделируемым устройством, и создание корректного программного интерфейса
является сложной задачей для человека. Пятое требование призвано добавить гибкости
в генерации кода, что должно позволить расширить возможности по использованию
полученных программных моделей и удобство структурирования проекта
разрабатываемой системы.

Готовые решения для моделирования, такие как Modelsim, LabVIEW и другие
описанные в разделе #ref(<средства_моделирования>, supplement: none) про
средства моделирования, решено не использовать по той причине, что они являются
проприетарными, не дают требуемой гибкости в создании и использовании моделей, и
их использование приведет к ограничению возможностей по расширению
разрабатываемого программного решения, например, в сторону использования
стороннего средства моделирования.

В соответствии с описанными требованиями был определен набор технологий для
реализации проекта.

== Обзор выбранных технологий

Было принято решение разработку программного модуля вести в отдельном
репозитории в интернет-сервисе GitHub и дать проекту название "Circulator".

Сборка проекта происходит с использование инструмента Gradle, так как он 
рекомендуется в официальной документации к языку Kotlin для мультиплатформенных
проектов. По той же причине этот инструмент выбран для реализации компонента
выполняющего генерацию кода: компонент должен иметь возможность встраиваться в
сборочный процесс. Непосредственно для генерации кода используется программная
библиотека Kotlin Poet, которая предоставляет программный интерфейс для
управления процессом генерации кода.

В качестве промежуточного представления принято решение использовать семейство
диалектов MLIR описанных в проекте CIRCT по той причине, что проект активно
развивается и такое промежуточное представление является наиболее гибким для
анализа, оптимизаций и другой обработки с помощью открытых компиляторных
технологий из проекта LLVM.  Кроме того, имеются или находятся в разработке
инструменты для получения этого промежуточного представления из популярных
языков описания аппаратуры вроде SystemVerilog и Chisel.

Для получения нативной модели из промежуточного представления используется
инструмент Arcilator, так как он предоставляет готовый пользовательский
интерфейс для использования набора преобразований необходимых для получения
LLVM IR из CIRCT IR, который далее используется для компиляции в нативный
код либо статической, либо динамической библиотеки. Этот инструмент выбран
в большей степени в силу своей простоты использования, но он не является
критичным для реализации; Arcilator вполне можно заменить на другие инструменты
предоставляющие возможность получения нативных моделей из описания аппаратуры,
например, более популярный Verilator или SystemC, но они не рассчитаны на работу
с промежуточным представлением, из-за чего очень специализированны для
конкретного языка описания аппаратуры и, кроме того, влекут использование их
собственной среды исполнения с усложненным ABI.

Компиляция LLVM IR в нативный код можно использовать стандартные инструменты
проекта LLVM, лучше всего для этого подходит драйвер clang, который
предоставляет пользовательский интерфейс для работы с другими утилитами,
такими как оптимизатор и компилятор LLVM IR. Также он позволяет сразу получить
нативные модели в виде динамически загружаемых библиотек.

Взаимодействие с нативным кодом может происходить различным образом,
в зависимости от требований проекта и платформы, используемой для
реализации системы. Так как фреймворк "Controls.kt" в основе своей
нацелен на использование платформы JVM, в разрабатываемом решении
так же сделан упор на эту платформу. 

Для обращения из JVM к нативному коду моделей принято решение использовать новый
программный интерфейс под названием FFM API, так как он является наиболее
современным и производительным. Эта технология в большей степени выбрана в силу
своей простоты с точки зрения использования, но она не является критичной. 

Таким образом, для реализации проекта выбраны технологии, которые позволяют
выполнить поставленные требования наиболее оптимально для его целевой области
применения.

= Обзор разработанного решения

В этой главе описывается реализация разработанного инструмента "Circulator" до
версии 0.1.0 включительно. Также в ней описываются условия и примеры его
использования для проведения сквозного тестирования.

Проект выполнен в соответствии с принципами мультиплатформенной разработки на
языке Kotlin и представляет собой программную библиотеку и плагин для системы
сборки Gradle. Проект структурирован как композитный проект в системе сборки
Gradle и содержит следующие модули.

- `circulator-core` --- ядро проекта, включаемое во все подпроекты Circulator.
  Оно реализуется как программная библиотека, предоставляющая абстракции для
  описания и использования моделей аппаратуры, а так же структуры данных для
  работы со средствами моделирования (Arcilator для указанной версии).
- `circulator-plugin` --- реализация плагина для системы сборки Gradle. Он
  принимает конфигурацию из сценария сборки, допольнительно конфигурирует проект и
  генерирует код на языке Kotlin.
- `demo` --- проект с подпроектами, демонстрирующими возможности использования
  инструмента.

== Общая архитектура проекта

Модуль `demo` включает в свой процесс сборки корневой проект, что важно для
использования актуальной версии плагина выполняющего генерацию кода. Несмотря на
неочевидную обратную зависимость подпроектов, такая конфигурация сборочного
процесса оказывается удобной во время разработки, так как при использовании
демонстрационного проекта в качестве корневого, среда разработки и система
сборки правильно решает зависимости.

Визуализация размещения модулей представлена на диаграмме /* TODO */

- диаграмма размещения

Центральный модуль проекта `circulator-core` предоставляет базовые абстракции для
создания модели прибора:

- класс для определения интерфейса для работы с моделью прибора ---
  `Model`,
- и класс для определения интрефейса для работы с нативной библиотекой ---
  `ModelLibrary`,
- классы делегатов для получения внутреннего состояния прибора следующие
  интерфейсу `StateProjection`.

Диаграмма классов визуализирующая взаимосвязь между компонентами представлена на
рисунке /* TODO */. Классы реализцющие интерфейс `StateProjection` выполняют
доступ к данным, расположенным во внешней помяти по отношению к куче JVM, и к
ним делегируется обращение к свойствам класса модели. Для примитивных типов
таких, как Byte, Int, Long и пр., отдельно реализованы классы, потому, как
доступ к сегменту памяти происходит не полиморфным, а зависимым от типа, образом.

- диаграмма классов для моделей,

Указанные классы оказываются сильно зависимыми от платформы JVM, так как
полагаются на пакет `java.lang.foreign` для работы с нативным кодом. В
результате, в мультимлатформенной части проекта оказывается класс определяющий
схему данным для работы с утилитой Arcilator и базовый набор типов состояний,
наблюдаемых в модели.  При дальнейшем развитии проекта предполагается реализация
обобщенного мультиплатформенного подхода для определения классов моделей, что
так же может быть полезно для использования с другими инструментами для создания
нативных моделей.

// === Принцип работы модели

Модель устройства содержит сегмент памяти, внешней для кучи JVM, в котором
сохраняется состояние модели. Размер этого сегмента соответствует значению
атрибута `numStateBytes` из файла состояний Arcilator. Обращение к этому сегменту
происходит через делегаты следующие интерфейсу `StateProjection<T>`,
параметризованного типом данных, представленного в проекции состояния.

Для каждого стандартного типа проекции имеется соответствующая
функция-конструктор, общий вид сигнатуры которых можно видеть на листинге /* TODO */.
Такая функция позволяет указать номер байта в сегменте памяти,
соответствующего началу данных отвечающих данной проектции. Используя эти
функции получается компактно определить интерфейс модели --- геттер и сеттер
свойства класса соответствующие проекции состояния делегируются объекту
полученному из функции примерно так: `var clock by input<Byte>(0)`.

```kotlin
fun <T> Model.input(offset: Long) = // ...
fun <T> Model.output(offset: Long) = // ...
fun <T> Model.register(offset: Long) = // ...
fun <T> Model.memory(offset: Long, layout: /* ... */) = // ...
fun <T> Model.wire(offset: Long) = // ...
```

Соответственно количеству бит используемых для хранения значения в проекции
состояния используется тип языка Kotlin допускающий весь диапозон значений.
Соответствие типов можно видеть в таблице /* TODO */.

- таблица трансляции количества бит в тип

После изменения значения свойства объекта необходимо выполнить рассчет состояния
модели, вызвав на нем метод `eval()`. Последовательность операций производимых
в системе можно представить в виде диаграммы на рисунке /* TODO */.

- диаграмма последовательности взаимодействия с моделью

== Архитектура плагина

Плагин для сборочной системы Gradle является ключевой действующей фигурой из
состава разрабатываемого инструмента, именно плагин выполняет необходимые действия
для получения рабочей модели устройства. Процесс работы с плагином состоит из
следующих этапов.

+ Конфигурация плагина.
+ Компиляция языка описания аппаратуры.
+ Генерация кода.
+ Использование полученной модели.

Для каждого этапа были проработаны нюансы его прохождения и разработана методика
действий; все они нашли отражение в архитектуре плагина.

=== Конфигурация

Конфигурация плагина производится через интерфейс системы сборки Gradle, то есть
в файле конфигурации `build.gradle.kts`, который находится в корне проекта
подлежащего сборке, согласно документации Gradle.

Плагин необходимо подключить в процесс сборки, указав его идентификатор в
соответствующей секции файла конфигурации, то есть так, как показано на листинге
/* TODO */.

```kt
plugins {
    // ... other plugins
    id("io.github.e1turin.circulator.plugin")
}
```

Плагин принимает конфигурацию в секции своего расширения так, как это показано
на листинге /* TODO */. Конфигурация плагина сознательно вынесена в отдельный
файл, потому что она может выглядеть громоздко в конфигурации сборки проекта, а
так же такое решение позволяет разделить конфигурации моделей и проекта.

```kt
circulator {
    config = file("src/jvmMain/resources/circulator/config.json5")
}
```

Перед тем, как рассмотреть схему данных конфигурации плагина рассмотрим формат
файла состояний утилиты Arcilator, который используется в конфигурации плагина.
Файл можно получить запустив Arcilator для модели в формате CIRCT IR с флагом
`--state-file`, указав через знак `=` путь до выходного файла. Этот файл
содержит описание характеристик моделей полученных на вход утилиты в формате
CIRCT IR. Пример содержимого файла представлен на листинге /* TODO вынести в приложение */.

```json
[
  {
    "name": "Counter",
    "numStateBytes": 8,
    "initialFnSym": "",
    "finalFnSym": "",
    "states": [
      {
        "name": "clk",
        "offset": 0,
        "numBits": 1,
        "type": "input"
      },
      {
        "name": "reset",
        "offset": 1,
        "numBits": 1,
        "type": "input"
      },
      {
        "name": "clk",
        "offset": 2,
        "numBits": 1,
        "type": "wire"
      },
      {
        "name": "reset",
        "offset": 3,
        "numBits": 1,
        "type": "wire"
      },
      {
        "name": "reg",
        "offset": 5,
        "numBits": 8,
        "type": "register"
      },
      {
        "name": "o",
        "offset": 6,
        "numBits": 8,
        "type": "wire"
      },
      {
        "name": "o",
        "offset": 7,
        "numBits": 8,
        "type": "output"
      }
    ]
  }
]
```

Формат файла не задокументирован и для того, чтобы понять его формат, потребовалось
изучить примеры использования утилиты для получения VCD файла с симуляцией работы
устройства /* TODO ссылка */ и исходный код утилиты /* TODO ссылка */. В
результате были выяснена схема данных этого файла, которую зафиксировали в файле 
`ArcilatorStateFileSchema.kt` проекта Circulator с использованием типов данных
Kotlin /* TODO листинг в приложение */.

Формат файла состояний содержит следующие важные атрибуты.

- `name` в описании модели --- название модели.
- `numStateBytes` --- размер структуры в байтах, используемой для хранения состояния.
- `initialFnSym`, `finalFnSym` --- название символов в выходном LLVM IR модуле
  соответствующих функции инициализации и функции завершения работы модели.
- `states` --- массив содержащий характеристики отдельных проекций состояния
  модели.
- `name` в описании проекции состояния --- название проекции.
- `offset` --- номер байта, начиная с которого располагается значение проекции 
  состояния в структуре состояния произведенной модели в виде LLVM IR.
- `numBits` --- количество бит требующихся для представления всех возможных
  значений проекции состояния.
- `type` --- тип проекции состояния, отвечающий ее назначению.

В описываемой версии 0.1.0 расширение принимает путь до конфигурация в формате
JSON, в частности JSON5, который позволяет использовать синтаксис для
комментариев. В конфигурационном файле указываются настройки для генерации
моделей отдельных устройств в формате представленном на листинге /* TODO */.
Формат JSON выбран среди прочих форматов представления данных как наиболее
популярный и простой для понимания.

```json
{
  "models": {
    "<model_id_name>": {
      "package": "com.example.generated",
      "state-file": "path/to/arcilator/state-file.json",
      "model": {
        "open": true,
        "all-states-open": true,
        "all-states-mutable": true,
        "all-states-type": [
          "input",
          "output",
          "register",
          "memory",
          "wire"
        ],
        "states": {
          "<state_id_name>": {
            "open": true,
            "mutable": true,
            "access": true
          },
          // ... other states
        }
      },
      "library": {
        "open": true
      },
    },
    // ... other models
  },
  "variables": {
    "<var_id_name>": "<var_value>"
  }
}
```

Рассмотрим основные элементы формата конфигурации.

- `<model_id_name>` --- атрибут с ключом содержащим идентификатор прибора, в
  значении которого находится конфигурация, в версии Circulator 0.1.0 значение
  этого ключа не используется, но в дальнейшем его можно использовать для
  внутренних нужд. Этот атрибут намерено добавлен в значении атрибута `model`,
  а не атрибутом в элементе массива, чтобы гарантировать уникальность
  идентификаторов и иметь возможность в редакторах кода навигироваться по ним.
- `package` --- атрибут cо строковым значением для указания названия пакета,
  в котором необходимо расположить сгенерированный Kotlin-класс.
- `state-file` --- атрибут со строковым значением, содержащим путь до файла
  проекций состояний.
- `all-states-open`, `all-states-mutable`, `all-states-types` --- атрибуты
  отвечающие конфигурации для всех проекций состояний модели сразу. Атрибуты
  соответственно отвечают возможности переопределять это свойство класса,
  записывать в это свойство и набор свойств с фильтрацией по их типу. Значение
  этого атрибута можно переопределить для отдельной проекции состояния с помощью
  следующего атрибута.
- `<state_id_name>` --- атрибут с ключом, содержащим название проекции
  состянияния, и значением, содержащим конфигурацию для генерации её программного
  интерфейса.
- `<var_id_name>` --- атрибут с ключом, содержащим уникальный индентификатор, и
  значением,  на которое можно использовать в конфигурации. На этот атрибут можно
  ссылаться в конфигурации.

В рассматриваемой версии Circulator 0.1.0 отсутствует конфигурация для
вспомогательных утилит участвующих в промежуточных этапах получения нативной
модели, потому что это выходит за рамки функциональности разрабатываемого
программного модуля. Эти этапы сильно зависят от конкретных используемых
инструментов и операционной системы, в которой исполняется процесс компиляции.
Тем не менее, в будущих версиях такая конфигурация может стать доступна.

=== Компиляция HDL

Процесс компиляции языков описания аппаратуры в нативный код представляет собой
так же многоэтапный процесс, который протекает независимо от Circulator версии
0.1.0. Плагин в составе Circulator создает зависимость своего этапа генерации кода
на результат протекания процесса компиляции, в частности на выходной файл
состояний утилиты Arcilator.

Рассмотрим этапы компиляции с учетом создаваемых промежуточных артефактов.
#v(1em)

/* TODO в виде таблицы */

1. Трансляция языка описания аппаратуры в промежуточное представление.\

  *Вход*: файл, содержащий исходный код на языке описания аппарутуры.\

  *Выход*: файл, содержащий промежуточное представление в зависимости от исходного языка.\

  *Инструмент*: Компилятор языка, например, плагин компиялтора Scala для Chisel.\

  *Пример*: Chisel в результате компиляции создает файл `DeviceName.fir` содержащий
  промежуточное представление в виде FIRRTL; альтернативно язык можно сразу
  скомпилировать в промежуточное представление одно из диалектов CIRCT: hw, firrtl,
  или даже SystemVerilog.

  *Примечание*: Для некоторых языков этот этап может быть пропущен, например, Verilog
  уже может считаться своим промежуточным представлением.
  #v(1em)

2. Трансляция промежуточного представления языка в один из основных
  диалектов CIRCT IR.

  *Вход*: файл, содержащий промежуточное представление языка описания аппаратуры.

  *Выход*: файл, содержащий промежуточное представление на одном из 
  основных диалектов CIRCT IR.

  *Инструмент*: Транслятор промежуточных представлений, например, 
  `firtool` или `circt-verilog`.

  *Пример*: Промежуточное редставление FIRRTL с помощью утилиты `firtool`
  транслируется в CIRCT IR диалект hw. Описание аппаратуры на языке Verilog с
  помощью утилиты `circt-verilog` компилируется в hw диалект CIRCT IR.
  #v(1em)

3. Компиляция CIRCT IR в симуляционную модель в виде LLVM IR.

  *Вход*: файл, содержащий промежуточное представление на одном из основных 
  диалектов CIRCT IR.

  *Выход*: файл, содержащий LLVM IR соответствующий логике симуляции 
  работы модели, и файл, содержащий характеристики симуляционной модели.

  *Инструмент*: утилита `arcilator`.

  *Пример*: Промежуточное представление устройсва в виде CIRCT IR диалекта
  hw c помощью утилиты `arcilator` транслируется в LLVM IR и с опцией
  `--state-file=states.json` создается дополнительный файл `states.json`,
  содержащий характеристики симуляционной модели устройтсва.

  *Примечание*: на этом этапе с помощью отдельных опций можно контролировать
  процесс трансляции в LLVM IR, отчего будет зависеть набор наблюдаемых
  состояний в файле характеристики модели. 
  #v(1em)

4. Компиляция симуляционной модели в виде LLVM IR в нативный код динамически
  загружаемой библиотеки.

  *Вход*. Файл содержащий LLVM IR.

  *Выход*. Файл дианамически загружаемой нативной библиотеки для данной операционной
  системы.

  *Инструмент*. Утилита `clang`.

  *Пример*. Файл содержащий нативный код симуляцонной модели в виде LLVM IR
  принимается в качестве аргумента утилитой `clang` с опциями для создания
  динамически загружаемой библиотеки (разделяемой библиотеки), примеры
  команд с опциями доступными на популярных операционных системах можно
  видеть на листинге /* TODO */.

  *Примечание*. Этот этап можно выполнить различным образом, в зависимости
  от требований к итоговому артефакту: можно выполнить дополнительную серию
  оптимизаций LLVM IR, можно скомпилировать модель в статическую библиотеку,
  можно объединить несколько моделей в один нативный модуль и т.д.


```sh
# Linux
clang -shared -o libcounter.so counter.ll

# Windows with definition file
clang -shared -o counter.dll counter.ll -Wl,/DEF:counter.def
# Windows with manual export
clang -shared -o counter.dll counter.ll -Wl,/EXPORT:Counter_eval

# MacOS
clang -nostartfiles -nodefaultlibs -dynamiclib -o libcounter.dylib counter.ll -lSystem
```

Соответственно описанной последовательности этапов, после прохождения третьего
из них появляется файл состояний симуляционной модели, требующийся для генерации
кода на следующем этапе работы с плагином Circulator.

На последнем, четвертом, этапе получается файл динамически загружаемой
библиотеки, который содержит функции, необходимые для работы приложения,
использующего требуемые модели аппаратуры.

=== Процесс генерации кода

Процесс генерации кода заключается в создании файлов с исходным 
кодом на языке Kotlin, реализующих логику взаимодействия с нативными
моделями, полученными на предыдущем этапе работы с плагином Circulator.

Генерация кода начинается с получения конфигурации, описывающей требования
к результирующим моделям, из файла указанного в конфигурации плагина. Далее в
соответствии с ней происходит генерация кода с использованием специализированной
библиотеки Kotlin Poet, предоставляющей программный интерфейс для описания
желаемого кода на языке Kotlin.

Плагин Circulator предоставляет дополнительную задачу для системы сборки Gradle,
которая находится в группе задач "circulator" и называется "generateKotlinClasses",
что можно видеть на листинге /* TODO */. При конфигурации проекта плагин добавляет
этой задаче зависимость от файла конфигурации и файлов указанных в файле конфигурации,
что позволяет отслеживать изменения в используемых артефактах предыдущих этапов.

```console
$ ./gradlew tasks --group=circulator
Calculating task graph as no cached configuration is available for tasks: tasks --group=circulator

> Task :tasks

------------------------------------------------------------
Tasks runnable from root project 'demo'
------------------------------------------------------------

Circulator tasks
----------------
compileCirctMlir - Run arcilator on MLIR output
compileChisel - Run Chisel FIRRTL producing for model Counter
compileFirrtl - Run firtool on Chisel FIRRTL output
compileLlvm - Run clang on model in LLVM IR
generateKotlinClasses - Generate Kotlin classes for defined models
runChiselPipeline - Run the full hardware compilation pipeline

To see all tasks and more detail, run gradlew tasks --all

To see more detail about a task, run gradlew help --task <task>

BUILD SUCCESSFUL in 818ms
7 actionable tasks: 1 executed, 6 up-to-date
Configuration cache entry stored.
```

Для удобства работы с плагином можно описать этапы компиляции HDL с помощью
отдельных задач системы сборки Gradle и добавить задаче "generateKotlinClasses"
зависимость на них так, как это показано для примера с Chisel на листинге /* TODO */.
Подобным образом можно сконфигурировать процесс сборки с другим языком
описания аппаратуры. 

```kotlin
/* in subproject 'chisel' */

val compileChisel = tasks.register<JavaExec>("compileChisel") {
  /* ... */
}

val compileFirrtl = tasks.register<Exec>("compileFirrtl") {
    dependsOn(compileChisel) /* ... */
}

val compileCirctMlir = tasks.register<Exec>("compileCirctMlir") {
    dependsOn(compileFirrtl) /* ... */
}

val compileLlvm = tasks.register<Exec>("compileLlvm") { 
    dependsOn(compileCirctMlir) /* ... */ 
}

val runFullPipeline = tasks.register("runChiselPipeline") {
    dependsOn(compileLlvm) /* ... */
}

/* In parent project */

tasks.named("generateKotlinClasses") {
    dependsOn(":chisel:runChiselPipeline")
}
```

В случае использования плагина с языком Chisel в одном проекте есть нюанс
связанный с последовательностью выполнения стандартных для Gradle задач ---
возникает ошибка из-за циклической зависимости задач. Дело в том, что
язык Scala, который используется в основе компилятора Chisel зависит от
Java классов, которые получаются, в том числе, в результате компиляции
классов Kotin. Но компиляция Kotlin в силу использования плагина Circulator
начинает зависеть от компиляции Chisel, и образуется циклическая зависимость
"Kotlin --- Chisel --- Scala --- Kotlin". Наиболее простой способ решить эту
проблему состоит в том, чтобы сделать отдельный проект, отвечающий за компиляцию
Chisel, а в проект использующий плагин Circulator добавить зависимость на
результат исполнения его задачи, что продемонстированно на листинге /* TODO */.
Такой подход решает еще и проблемы возникающие при одновременном использовании
плагина Scala и Kotlin Multiplatform для системы сборки Gradle в одном проекте.

== Использование модели

После выполненной генерации кода классы Kotlin становятся доступны для
использования в программном коде разрабатываемого приложения по имени
пакета, указанного в конфигурации плагина, и имени класса указанному в файле
состояний Arcilator.

=== Условия использования

Для работы с моделью, необходимо выполнить следующие условия.

1. При создании модели должно быть указано *платформонезависимое* имя библиотеки,
   полученной в результате компиляции на предыдущем этапе.
2. Динамическая библиотека должна быть расположена в известных для JVM путях
   файловой системы для поиска библиотек под ее *платформозависимым* именем.
3. При запуске JVM должна быть указана опция, разрешающая доступ к нативной памяти.
4. При создании модели должна быть создана арена внешней памяти соответствующая
   цели использования модели.

Первое условие связано с независимым от платформы (операционной системы)
исполнением кода в JVM, потому как JVM делегирует поиск и загрузку динамической
библиотеки операционной системе, а формат именования таких библиотек на них
отличается.

Второе условие связато с тем, как работает динамический загрузчик библиотек
--- он ищет лишь в определенных путях, в том числе тех, которые указываются при
запуске JVM в свойстве `java.library.path` и/или переменной окружения в
зависимости от операционной системы: `LD_LIBRARY_PATH` на Linux, `DYLD_LIBRARY_PATH` на MacOS.
- https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/System.html#load(java.lang.String)
- https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/System.html#loadLibrary(java.lang.String)
Модель при создании автоматически загружает библиотеку по имени.

Третье условие связано с политикой безопасности при работе с FFM API
https://openjdk.org/jeps/472. Спецификация OpenJDK требует указывать опцию
`--allow-native-access` с названием модулей обладающих разрешением.

Четвертое условие связано с поведением JVM при работе с аренам поддерживающих
интерфейс `java.lang.foreign.Arena` в многопоточном приложении. FFM API
предоставляет три вида арен обладающих своими свойствами, одно из которых
возможность доступа из потока отличного от того, на котором арена была создана.
С точки зрения работы моделей приборов, код исполняется в одном потоке
независимо от конкретно типа используемой арены, поэтому если обращаться к
модели из разных потоков, может возникнуть исключение `WrongThreadException`.
Таким образом, нужно либо использовать специальный тип арен доступных из
фабричного метода `Arena::ofShared` интерфейса, либо фиксировать поток, из
которого происходит обращение к модели устройства.


=== Пример использования

Рассмотрим примеры использования модели счетчика реализованной на языке Chisel,
которую можно видеть на листинге /* TODO */,
сначала в виде простого приложения командной строки, потом в виде компонента в
составе системы реализованной с помощью фреймворка Controls.kt. Эти примеры
взяты из демонтрационных проектов представленных в репозитории.

```scala
class CounterChisel extends Module {
  val count = IO(Output(UInt(8.W)))
  
  val counter = RegInit(0.U(8.W))
  count := counter

  counter := counter + 1.U
}
```

В обоих примерах создание модели происходит автоматически из описания прибора на
языке Chisel благодаря настроенным задачам и зависимостям между ними, описанными
в разделе про компиляцию HDL. Пример вывода утилиты `gradle`, подтверждающей это
можно видеть на листинге /* TODO */.

```console
Reusing configuration cache.
...
> Task :sandbox:chisel:compileCounterChisel
> Task :sandbox:chisel:compileFirrtl
> Task :sandbox:chisel:compileCirctMlir
> Task :sandbox:chisel:compileLlvm
> Task :sandbox:chisel:runChiselPipeline
> Task :sandbox:generateKotlinClasses
> Task :sandbox:compileKotlinJvm
> Task :sandbox:compileJvmMainJava
> Task :sandbox:jvmMainClasses
> Task :sandbox:runJvmCounter
Hello JVM World!
...
```

==== Простой пример

В качестве простого примера использования счетчика можно привести тест его
работоспособности: создание объекта модели, инициализация, использование,
проверка количества отсчетов. Исходный код примера приведен на листинге /* TODO */.

Аппаратный модуль счетчика реализует функцию подсчета положительных фронтов
входного тактового сигнала. Для моделирования поведения тактового сигнала
используется функция `CounterChiselModel.tick()`, которая циклически сменяет
значение входного сигнала, записывая значения 1 или 0, соответствующие
положительному и отрицательному фронту сигналав, в свойство `clock` модели.

Инициализация счетчика вынесена в отдельную функцию `CounterChiselModel.init()`.
Принцип ее работы соответствует принципу работы системы сброса устройства: на
входной порт необходимо подать логическую единицу и дождаться следующего такта.
Для пущей надежности, как это обычно делают при тестировании дизайнов аппаратных
блоков, до прекращения сброса ожидают несколько тактов.

Так как модель используется в одном потоке, который и создает арену для аллокации
сегмента памяти хранящего состояние модели, создаетсяа рена с ограниченной областью
использования, т.е. с помощью фабричного метода `Arena::ofConfinded`.

Основная функция выполняет следующие действия.

+ Создает арену.
+ Создает объект модели счетчика, используя арену.
+ Инициализирует счетчик.
+ Ожидает 10 циклов тактового сигнала.
+ Считывает результат со счетчика.
+ Успешно проверяет результат на равенство ожидаемому значению 10.

#figure[
  #include "res/code/basic-example.typ"
]


==== Пример с Controls.kt <пример_с_Controls.kt>

В качестве более сложного примера использования модели используется
счетчик в составе прибора на базе фреймворка Controls.kt с графическим
интерфейсом реализованным с использованием фреймворка Compose Multiplatform.
Основные элементы коды можно видеть на листинге /* TODO */.

Пример демонстрирует способ интеграции модели прибора из фреймворка Controls.kt
с моделью прибора созданного с помощью Circulator. Согласно документации в
примере создается класс, который реализует интерфейс прибора и определяет
спецификацию работы с этим прибором. Обращения к свойствам и методам модели
прибора из Controls.kt делегируется модели прибора из Circulator, можно найти
сходство этого примера с ранее продемонстрированным простым примером.

Модель счетчика создается в контроллере посредством менеджера устройств
DeviceManager из Controls.kt, который подключает все устройства в одну систему.
Далее контроллер используется при работе панели управления счетчиком.

Функция `CounterDeviceController.Panel()` отрисовывает графический интерфейс
приложения, реализующего возможность автоматического и ручного увеличения счета,
а также сброса. Внешний вид этого приложения можно видеть на рисунке /* TODO */.

#image("./res/img/counter-clicker-gui.png")

В этом примере арена, используемая для аллокации сегмента памяти внутри модели,
получается из фабричного метода `Arena::ofShared` по той причине, что оба фреймворка,
используемых в примере, работают в многопоточном асинхронном режиме и обращения
к модели устройства происходят из различных потоков. Фиксация потока,
о которой говорится в разделе об условиях использования моделей Circulator, для
простоты примера не производилась.

По сути, приложение использует прибор, который еще не произведен и имеется лишь
в виде дизайна на языке описания аппаратуры, но уже в таком виде его можно
использовать для построения системы и поиска недостатков. Стоит заметить, что
приложение работает отзывчиво, и задержка обновления счета по нажатию
кнопки не наблюдается.

/* TODO: move to application */
#figure[
  #include "res/code/gui-example.typ"
]

Этот пример, несмотря на его примитивность, может служить демонстрацией
выполнения сквозного тестирования системы от нажатия на кнопку до отображения
счета на экране. Во время использования этого приложения было выяснено, что
в системе возникает проблема представления данных: счетчих хранит безнаковое
представление числа, а экран ожидает для отображения число в знаковом
представлении, из-за чего при достижении значения счета 128 происходит знаковое
переполнение и отображается -128. При этом счетчик напрямую с экраном не
взаимодействует, потому что за передачу данных между компонентами отвечает
контроллер.

#image("res/img/counter-clicker-gui-bug.png")

Более формально результат тестирования выглядит так:

- *Действие*: нажать кнопку "click" 128 раз.
- *Ожидаемый результат*: значение счетчика 128.
- *Фактический результат*: значение счетчика -128.
- *Проблема*: неверное значение счетчика.
- *Причина*: знаковое переполнение при отображении значения счетчика.

Исправление этого недостатка системы заключается в изменении интерфейса
управления экраном: тип входных данных должен допускать полный диапозон значений
счетчика. После использования типа `Int` для входного значения экрана система
работает предсказуемо, и позволяет вести подсчет вплоть до значения 255 без
переполнения, что можно видеть на рисунке /* TODO */. Таким образом, сквозное
тестирование с применением моделей Circulator позволяет повышать качество
разрабатываемых систем.

#image("res/img/counter-clicker-gui-fix.png")

= Анализ результатов

В этой главе производится анализ результатов выполнения научно-исследовательской
работы, разработанное решение сравнивается с прочими готовыми решениями и
подходами по достижению поставленной цели, предлагаются варианты использования
инструмента Circulator, и рассматриваются перспективы его развития в будущих
версиях. /* TODO */

== Сравнение с альтернативными решениями

Сравнение разработанного решения Circulator с имеющимися на рынке программными
решениями для моделирования аппаратуры по нескольким ключевым критериям:

- доступность,
- функциональность,
- расширяемость,

#noindent[
  представлено в виде сводной таблицы /* TODO */.
]
#table(
  columns: 3,
  [*Критерий*], 
    [*Circulator*], 
    [*Другие инструменты*], 
  [*Доступность*],
    [Бесплатный и с открытым исходным кодом], 
    [В основном проприетарные с дорогой лицензией], 
  [*Функциональность*],
    [Сфокусирован на интеграции и генерации кода для JVM], 
    [Широкие возможности моделирования и симуляции], 
  [*Расширяемость*], 
    [Высокая расширяемость благодаря открытости кода], 
    [Ограниченная расширяемость, часто привязана к экосистемам поставщиков],
  [*Целевая аудитория*], 
    [Разработчики, использующие Kotlin/JVM],
    [Инженеры и исследователи в области проектирования аппаратуры],
  [*Интеграция*],
    [Бесшовная интеграция с системами на основе JVM],
    [Автономные инструменты с ограниченными возможностями интеграции],
  [*Кривая обучения*], 
    [Требует знаний Kotlin и JVM], [Различается, часто требует специализированных знаний],
  [*Гибкость*],
    [Поддерживает несколько языков описания аппаратуры через промежуточное представление],
    [Часто привязаны к конкретным языкам или фреймворкам], 
)

В первую очередь, Circulator является свободным программным обеспечением,
распространяемым под лицензией Apache 2.0.

Функциональность Circulator в актуальной версии 0.1.0 на порядок меньше, чем у
других программных решений, разрабатываемых компаниями, и пользовательский
интерфейс, в виде программного кода, может быть менее понятен для людей не
знакомых с программированием на языке Kotlin и платформой JVM. Но разработанное
решение отвечает заявленным для него требованиям и целевой аудитории
пользователей.

В силу своей открытости, Circulator обладает возможностью "бесконечного
расширения" функциональности, как обыкновенный программный код, что не
свойственно закрытым проприетарным продуктам, хотя некоторые из них
предоставляют программный интерфейс на одном из языков общего назначения:
Python, Julia, Lua и другие.

Проект Circulator не ограничивается конкретным набором совместимых технологий,
вместо этого он предоставляет API для взаимодействия и полагается на
промежуточное представление. Библиотека совместима с другими проектами, 
работающими на платформе JVM и не обязательно использующими язык Kotlin.

Разработанное решение не стремится заменить имеющиеся решения для создания и
использования моделей аппаратуры, оно занимает позицию между ними и системами
полагающимися на разработанные модели, т.е. Circulator выступает в роли
интегратора готовых дизайнов или моделей аппаратуры в управляющую систему по
типу Controls.kt --- подобного рода "бесконечно расширяемую" систему.
Инструмент нацелен на использование при сквозном тестировании не
аппаратных модулей, а систем, использующих эти модули, что демонстрируется
на примере в разделе #ref(<пример_с_Controls.kt>, supplement: none).

== Способы применения

Применение Circulator по целевому назначению предполагает совместное
использование генерируемых моделей с виртуальными устройствами фреймворка
Controls.kt при выполнении тестовых сценариев. Наличие API на языке Kotlin
позволяет использовать популярные фреймворки для тестирования и современные
подходы такие, как "fuzzing" и "Property-based" тестирование.

Кроме того, можно предложить другой сценарии использования разработанного
инструмента --- верификация готовой модели устройства с помощью сгенерированной
Circulator модели. В таком виде получается производить модульное тестирование
модели устройства.

Среди альтернативных направлений использования Circulator можно увидеть
- разработку учебных демонстрационных моделей устройств,
- модульное и функциональное тестирование дизайна аппаратного модуля
  рядовыми инженерами по автоматизированному тестированию программного обеспечения
- и разработка тестовых сценариев, называемых "testbench", в
  проектах на языке Chisel, с последующим их исполнением.

== Перспективы развития

Реализованная версия 0.1.0 проекта Circulator обладает достаточной
функциональностью для соответствия поставленным ей требованиям, тем не менее
можно рассмотреть возможности для дальнейшего развития проекта. 

Пути развития функциональности проекта связаны с расширением набора технологий
доступных для использования, который сильно ограничен в данной версии, об этом
говорилось в разделе #ref(<требования_к_проекту>, supplement: none) про
требования к проекту. А именно, потенциал развития имеют следующие аспекты.

- Поддержка средств создания нативных моделей и симуляции, отличных от
  Arcilator.  Например, Verilator и SystemC, которые не полагаются на
  промежуточное представление.
- Поддержка других способов взаимодействия с нативными библиотеками. Например,
  JNI или возможности Kotlin/Native.
- Поддержка платформ для запуска моделей, отличных от JVM. Примерами таких
  платформ могут быть Native и WASM.

Также можно рассмотреть варианты добавления в плагин сборочной системы Gradle
возможностей по конфигурированию проектов, направленных на разработку дизайна
аппаратных модулей, и создание входящего в проект Circulator доменно
специфичного языка для описания аппаратных модулей на базе языка Kotlin.

// #struct
= ЗАКЛЮЧЕНИЕ

В данной работе был описан процесс разработки программного модуля
предоставляющего возможности моделирования аппаратуры на уровне цифровых схем
для виртуальных устройств фреймворка Controls.kt. На примере демонстрационного
проекта показано, что цель работы достигнута: с использованием разработанного
решения можно проводить сквозное тестирование системы для обнаружения
недостатков, исправление которых ведет к повышению качества системы.

// ..

// #struct
= СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ

// #struct
= ПРИЛОЖЕНИЕ
